[
["strings.html", "5 Строки 5.1 Установка дополнительных пакетов 5.2 Создание строк 5.3 Конкатенация строк 5.4 Разделение строк 5.5 Сортировка строк 5.6 Изменение регистра 5.7 Поиск подстроки 5.8 Изменение строк 5.9 Регулярные выражения", " 5 Строки Мы уже знакомились со строковым типом данных character. Но мы обозначили, что многие операции над этим типом невозможны (например, нельзя сложить две строки). Возникает вопрос: что делать? Для начала научимся ставить дополнительные пакеты. 5.1 Установка дополнительных пакетов В самом начале мы упоминали, что R имеет большие возможности расширения функционала с помощью специальных пакетов. Для работы со строками нам будут нужны два — stringi («стринг-ай») и stringr («стринг-ар»). На их примере мы и разберем механизм установки и подключения дополнительных пакетов. Пакет — это набор функций, не входящих в «базовую комплектацию R», которые, как правило, специализированы под те или иные задачи. В нашем случае — под работу со строками. Поэтому сначала пакет необходимо скачать на комп: install.packages(c(&quot;stringi&quot;, &quot;stringr&quot;)) В функцию install.packages() необходимо передать строковый вектор, содержащий названия пакетов, которые мы бы хотели установить. Часто одни пакеты ссылаются на функции других, поэтому можно указать в аргументе dependencies TRUE, чтобы попутно установились зависимые пакеты. install.packages(c(&quot;stringi&quot;, &quot;stringr&quot;), dependencies = TRUE) По умолчанию пакеты скачиваются с репозитория CRAN — основное хранилище, где лежит подавляющее большинство пакетов и всякого разного. Но может быть такое, что установить соединение с этим репозиторием по каким-либо причинам не получается. Чтобы пофиксить сей баг, нужно указать в настройках какое-либо из зеркал. Options → Packages → Primary CRAN repository → Change…, и выбрать что-то. Если не помогло — попробуйте ещё. Но мало просто скачать пакет. Надо его ещё подключить к текущей сессии, в которой мы работаем. Для этого используется функция library(stringi) ## Warning: package &#39;stringi&#39; was built under R version 3.6.2 library(stringr) Ей уже надо скормить название пакета без кавычек, и для подключения каждого пакета потребуется написать новую строчку. Тут запутываются термины «пакет» и «библиотека», но опустим эти детали и примем сей момент как есть… После того, как мы подключили пакет к данной сессии, мы можем использовать функции из него. Кайф, поехали! 5.2 Создание строк Можно сделать строку руками (наблюдайте за кавычками): s1 &lt;- &quot;сложившаяся структура организации влечет за собой процесс внедрения и модернизации новых предложений&quot; s1 ## [1] &quot;сложившаяся структура организации влечет за собой процесс внедрения и модернизации новых предложений&quot; s2 &lt;- &#39;С другой стороны постоянный количественный &quot;рост&quot; и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации&#39; s2 ## [1] &quot;С другой стороны постоянный количественный \\&quot;рост\\&quot; и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации&quot; s3 &lt;- &quot;С другой стороны постоянный количественный &quot;рост&quot; и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации&quot; s3 ## Error: &lt;text&gt;:1:52: unexpected symbol ## 1: s3 &lt;- &quot;С другой стороны постоянный количественный &quot;рост ## ^ s4 &lt;- &quot;С другой стороны постоянный количественный &#39;рост&#39; и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации&quot; s4 ## [1] &quot;С другой стороны постоянный количественный &#39;рост&#39; и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации&quot; s5 &lt;- &quot;С другой стороны постоянный количественный «рост» и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации&quot; s5 ## [1] &quot;С другой стороны постоянный количественный «рост» и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации&quot; s6 &lt;- &quot;&quot; # это пустая строка s6 ## [1] &quot;&quot; Также можно использовать функцию character()1 для создания вектора из пустых строк: character(5) ## [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; А также функции для приведения типов, которые мы уже обсуждали: as.character(1:30) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;14&quot; ## [15] &quot;15&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot; &quot;20&quot; &quot;21&quot; &quot;22&quot; &quot;23&quot; &quot;24&quot; &quot;25&quot; &quot;26&quot; &quot;27&quot; &quot;28&quot; ## [29] &quot;29&quot; &quot;30&quot; Кроме того, существуют встроенные текстовые векторы: letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; ## [18] &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; ## [18] &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; &lt;img class=“taskimg” src=&quot;img/question.png&gt; Есть ещё встроенные векторы, которые содержат названия месяцев и аббревиатуры названий месяцев. Отыщите их. Мы умеем генерировать числавые последовательности. Можно также генерировать и строки. Например, когда вы хотите сгенерировать ID для испытуемых не просто как числа, а как уникальные текстовые значения: stri_rand_strings(n = 10, length = 5) ## [1] &quot;deTPj&quot; &quot;VfGwS&quot; &quot;O7X0R&quot; &quot;cLQ4K&quot; &quot;BHvRs&quot; &quot;7osCa&quot; &quot;5GD2R&quot; &quot;o4fh9&quot; ## [9] &quot;AIs2B&quot; &quot;pKqY6&quot; Фнукции из пакета stringi начинаются с префикса stri, а функции пакета stringr — с префикса str. Их легко можно опознать. Средствами stringi можно генерировать не только случайные строки, но и «рыбу»-текст. Один из вариант такого текста — широко известный «Lorem ipsum». Найдите функцию, которая генерирует такой текст и сгенерируйте четыре абзаца. ## [1] &quot;Lorem ipsum dolor sit amet, a sit nisl at facilisis sapien. Euismod enim non habitasse dolor in at donec mus lectus viverra? At ante luctus eu eget non. Ligula convallis mi scelerisque habitasse. Sed gravida egestas ut amet diam libero ut non sagittis at. Ante erat placerat justo curae mi, suscipit. Interdum lacus, nostra tristique, phasellus turpis. Id commodo eros eu non mus porta, orci phasellus habitant nulla dolor. Praesent pellentesque aliquam in lacus libero, tempus nibh etiam velit. Faucibus, quisque libero. Suspendisse finibus volutpat et sed. Ex sed sapien vestibulum conubia et amet sed dictumst. Fermentum et sollicitudin posuere. Euismod felis, vel turpis senectus mollis magna. Ipsum ut, per varius vehicula mus nec. Vivamus purus ac blandit venenatis dapibus erat habitasse posuere.&quot; ## [2] &quot;Aenean et convallis augue magnis in scelerisque. Pellentesque augue amet posuere risus ultrices et, gravida facilisis faucibus ac. Condimentum nunc eu lacus. Tellus quam est, magna egestas aptent quis sit sapien sed ut, aliquam. Posuere nec et lectus curae ornare ultrices ad nec, ac, integer. Vulputate, duis egestas est. Sed ullamcorper tempor pharetra maecenas ut lorem. Tellus justo at felis integer sodales? Urna et dapibus cubilia in tempus pretium, amet. Placerat hac pulvinar. Purus vestibulum metus in ornare sagittis tellus donec, nisl, dictum. Mi leo congue ac. Ornare leo tincidunt et felis eu, ligula sed finibus quam. Porta primis lacus dictum donec eget metus a turpis. Pulvinar, cras nisi, egestas pretium nulla aenean.&quot; ## [3] &quot;Aliquam nunc ut, amet curabitur habitasse in in metus viverra tristique. Cum quis ligula mus et fringilla commodo sollicitudin tincidunt lobortis fermentum. Tincidunt, mollis, in donec tincidunt volutpat tempus quis habitant. Nullam quis porta eros aliquet commodo mauris donec a egestas diam erat. Morbi sagittis posuere et litora ex commodo. Vestibulum condimentum natoque mi etiam eu semper eget? Sed ultricies sed ultrices vehicula finibus, et tortor dictum lobortis ante porta conubia. Erat suscipit eleifend netus laoreet turpis dictum duis a! Felis condimentum ac tristique quis tempus, quam vivamus augue praesent sed ante. Tristique metus orci sed a aliquam ultrices erat.&quot; ## [4] &quot;Nisl sed, feugiat congue vel lorem vestibulum mollis, integer. Gravida fringilla et et sed ultrices ex cursus fringilla curae inceptos. Arcu elit neque adipiscing ut ante. Sed blandit mauris, a sit ornare sed nunc rutrum ipsum posuere ut magna. Eros ligula in sociis maximus eget purus arcu, malesuada sed, in. Gravida sed tincidunt, in justo ex, sociis. Tortor laoreet, ultricies, mollis aliquam. Sed purus ad mauris cras viverra et. Adipiscing morbi sed commodo ligula id tincidunt et vehicula ut venenatis eu.&quot; 5.3 Конкатенация строк Строки можно соединять воедино: paste(&#39;first&#39;, &#39;second&#39;, &#39;third&#39;) # базовый R ## [1] &quot;first second third&quot; paste(&#39;first&#39;, &#39;second&#39;, &#39;third&#39;, sep = &quot;_&quot;) ## [1] &quot;first_second_third&quot; paste0(&#39;first&#39;, &#39;second&#39;, &#39;third&#39;) ## [1] &quot;firstsecondthird&quot; stri_c(&#39;first&#39;, &#39;second&#39;, &#39;third&#39;) # пакет stringi ## [1] &quot;firstsecondthird&quot; stri_c(&#39;first&#39;, &#39;second&#39;, &#39;third&#39;, sep = &quot; &amp; &quot;) # пакет stringi ## [1] &quot;first &amp; second &amp; third&quot; Сгенерируйте вектор, который будет описывать различные сочетания условий вашего гипотетического эксперимента, который вы сможете добавить в гипотетический датафрейм. Пусть у вас будет десять испытуемых, для каждого из которого в датафрейме предусмотрено четыре строки: две под условие A1 и две под условие A2. В свою очередь каждое из условий A может сочетаться с вариантами условия B (B1 и B2). В итоге у вас должен получиться вектор, каждое значение которого структурно выглядит так: ID_условиеA_условиеB. ## [1] &quot;1_A1_B1&quot; &quot;1_A1_B2&quot; &quot;1_A2_B1&quot; &quot;1_A2_B2&quot; &quot;2_A1_B1&quot; &quot;2_A1_B2&quot; ## [7] &quot;2_A2_B1&quot; &quot;2_A2_B2&quot; &quot;3_A1_B1&quot; &quot;3_A1_B2&quot; &quot;3_A2_B1&quot; &quot;3_A2_B2&quot; ## [13] &quot;4_A1_B1&quot; &quot;4_A1_B2&quot; &quot;4_A2_B1&quot; &quot;4_A2_B2&quot; &quot;5_A1_B1&quot; &quot;5_A1_B2&quot; ## [19] &quot;5_A2_B1&quot; &quot;5_A2_B2&quot; &quot;6_A1_B1&quot; &quot;6_A1_B2&quot; &quot;6_A2_B1&quot; &quot;6_A2_B2&quot; ## [25] &quot;7_A1_B1&quot; &quot;7_A1_B2&quot; &quot;7_A2_B1&quot; &quot;7_A2_B2&quot; &quot;8_A1_B1&quot; &quot;8_A1_B2&quot; ## [31] &quot;8_A2_B1&quot; &quot;8_A2_B2&quot; &quot;9_A1_B1&quot; &quot;9_A1_B2&quot; &quot;9_A2_B1&quot; &quot;9_A2_B2&quot; ## [37] &quot;10_A1_B1&quot; &quot;10_A1_B2&quot; &quot;10_A2_B1&quot; &quot;10_A2_B2&quot; 5.4 Разделение строк Если добрый коллега записал экспериментальные условия в одну переменную как выше, а вам нужно делать по ним, например, какую-нибудь анову, то можно на него долго ругаться, а можно разделить строки обратно: str_split(s_exp, pattern = &quot;_&quot;) ## [[1]] ## [1] &quot;1&quot; &quot;A1&quot; &quot;B1&quot; ## ## [[2]] ## [1] &quot;1&quot; &quot;A1&quot; &quot;B2&quot; ## ## [[3]] ## [1] &quot;1&quot; &quot;A2&quot; &quot;B1&quot; ## ## [[4]] ## [1] &quot;1&quot; &quot;A2&quot; &quot;B2&quot; ## ## [[5]] ## [1] &quot;2&quot; &quot;A1&quot; &quot;B1&quot; ## ## [[6]] ## [1] &quot;2&quot; &quot;A1&quot; &quot;B2&quot; ## ## [[7]] ## [1] &quot;2&quot; &quot;A2&quot; &quot;B1&quot; ## ## [[8]] ## [1] &quot;2&quot; &quot;A2&quot; &quot;B2&quot; ## ## [[9]] ## [1] &quot;3&quot; &quot;A1&quot; &quot;B1&quot; ## ## [[10]] ## [1] &quot;3&quot; &quot;A1&quot; &quot;B2&quot; ## ## [[11]] ## [1] &quot;3&quot; &quot;A2&quot; &quot;B1&quot; ## ## [[12]] ## [1] &quot;3&quot; &quot;A2&quot; &quot;B2&quot; ## ## [[13]] ## [1] &quot;4&quot; &quot;A1&quot; &quot;B1&quot; ## ## [[14]] ## [1] &quot;4&quot; &quot;A1&quot; &quot;B2&quot; ## ## [[15]] ## [1] &quot;4&quot; &quot;A2&quot; &quot;B1&quot; ## ## [[16]] ## [1] &quot;4&quot; &quot;A2&quot; &quot;B2&quot; ## ## [[17]] ## [1] &quot;5&quot; &quot;A1&quot; &quot;B1&quot; ## ## [[18]] ## [1] &quot;5&quot; &quot;A1&quot; &quot;B2&quot; ## ## [[19]] ## [1] &quot;5&quot; &quot;A2&quot; &quot;B1&quot; ## ## [[20]] ## [1] &quot;5&quot; &quot;A2&quot; &quot;B2&quot; ## ## [[21]] ## [1] &quot;6&quot; &quot;A1&quot; &quot;B1&quot; ## ## [[22]] ## [1] &quot;6&quot; &quot;A1&quot; &quot;B2&quot; ## ## [[23]] ## [1] &quot;6&quot; &quot;A2&quot; &quot;B1&quot; ## ## [[24]] ## [1] &quot;6&quot; &quot;A2&quot; &quot;B2&quot; ## ## [[25]] ## [1] &quot;7&quot; &quot;A1&quot; &quot;B1&quot; ## ## [[26]] ## [1] &quot;7&quot; &quot;A1&quot; &quot;B2&quot; ## ## [[27]] ## [1] &quot;7&quot; &quot;A2&quot; &quot;B1&quot; ## ## [[28]] ## [1] &quot;7&quot; &quot;A2&quot; &quot;B2&quot; ## ## [[29]] ## [1] &quot;8&quot; &quot;A1&quot; &quot;B1&quot; ## ## [[30]] ## [1] &quot;8&quot; &quot;A1&quot; &quot;B2&quot; ## ## [[31]] ## [1] &quot;8&quot; &quot;A2&quot; &quot;B1&quot; ## ## [[32]] ## [1] &quot;8&quot; &quot;A2&quot; &quot;B2&quot; ## ## [[33]] ## [1] &quot;9&quot; &quot;A1&quot; &quot;B1&quot; ## ## [[34]] ## [1] &quot;9&quot; &quot;A1&quot; &quot;B2&quot; ## ## [[35]] ## [1] &quot;9&quot; &quot;A2&quot; &quot;B1&quot; ## ## [[36]] ## [1] &quot;9&quot; &quot;A2&quot; &quot;B2&quot; ## ## [[37]] ## [1] &quot;10&quot; &quot;A1&quot; &quot;B1&quot; ## ## [[38]] ## [1] &quot;10&quot; &quot;A1&quot; &quot;B2&quot; ## ## [[39]] ## [1] &quot;10&quot; &quot;A2&quot; &quot;B1&quot; ## ## [[40]] ## [1] &quot;10&quot; &quot;A2&quot; &quot;B2&quot; Нам вернулся список. Шо с ним делать — вопрос хороший. Можно развернуть список в вектор и индексацией вытащить нужные нам части. Возьмите список, которые вернула функция str_split(), разверните его в вектор с помощью функции unlist() и вытащите из него по отдельности ID, условия A и условия B. ## [1] &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;3&quot; &quot;3&quot; &quot;3&quot; &quot;3&quot; &quot;4&quot; &quot;4&quot; ## [15] &quot;4&quot; &quot;4&quot; &quot;5&quot; &quot;5&quot; &quot;5&quot; &quot;5&quot; &quot;6&quot; &quot;6&quot; &quot;6&quot; &quot;6&quot; &quot;7&quot; &quot;7&quot; &quot;7&quot; &quot;7&quot; ## [29] &quot;8&quot; &quot;8&quot; &quot;8&quot; &quot;8&quot; &quot;9&quot; &quot;9&quot; &quot;9&quot; &quot;9&quot; &quot;10&quot; &quot;10&quot; &quot;10&quot; &quot;10&quot; ## [1] &quot;A1&quot; &quot;A1&quot; &quot;A2&quot; &quot;A2&quot; &quot;A1&quot; &quot;A1&quot; &quot;A2&quot; &quot;A2&quot; &quot;A1&quot; &quot;A1&quot; &quot;A2&quot; &quot;A2&quot; &quot;A1&quot; &quot;A1&quot; ## [15] &quot;A2&quot; &quot;A2&quot; &quot;A1&quot; &quot;A1&quot; &quot;A2&quot; &quot;A2&quot; &quot;A1&quot; &quot;A1&quot; &quot;A2&quot; &quot;A2&quot; &quot;A1&quot; &quot;A1&quot; &quot;A2&quot; &quot;A2&quot; ## [29] &quot;A1&quot; &quot;A1&quot; &quot;A2&quot; &quot;A2&quot; &quot;A1&quot; &quot;A1&quot; &quot;A2&quot; &quot;A2&quot; &quot;A1&quot; &quot;A1&quot; &quot;A2&quot; &quot;A2&quot; ## [1] &quot;B1&quot; &quot;B2&quot; &quot;B1&quot; &quot;B2&quot; &quot;B1&quot; &quot;B2&quot; &quot;B1&quot; &quot;B2&quot; &quot;B1&quot; &quot;B2&quot; &quot;B1&quot; &quot;B2&quot; &quot;B1&quot; &quot;B2&quot; ## [15] &quot;B1&quot; &quot;B2&quot; &quot;B1&quot; &quot;B2&quot; &quot;B1&quot; &quot;B2&quot; &quot;B1&quot; &quot;B2&quot; &quot;B1&quot; &quot;B2&quot; &quot;B1&quot; &quot;B2&quot; &quot;B1&quot; &quot;B2&quot; ## [29] &quot;B1&quot; &quot;B2&quot; &quot;B1&quot; &quot;B2&quot; &quot;B1&quot; &quot;B2&quot; &quot;B1&quot; &quot;B2&quot; &quot;B1&quot; &quot;B2&quot; &quot;B1&quot; &quot;B2&quot; Но есть более удобная функция separate(), которая разбивает субстроки сразу по колонкам. Её мы вспомним, когда будет говорить о предобработке данных. 5.5 Сортировка строк Строки можно сортировать: unsorted_s &lt;- paste0( sample(LETTERS, size = length(LETTERS), replace = TRUE), sample(letters, size = length(letters)), sample(letters, size = length(letters)) ) # делаем несортированный вектор из трёхбуквенных «слов» unsorted_s ## [1] &quot;Rxi&quot; &quot;Fpo&quot; &quot;Byn&quot; &quot;Jsz&quot; &quot;Qmj&quot; &quot;Wdl&quot; &quot;Ejq&quot; &quot;Caa&quot; &quot;Rgv&quot; &quot;Bcg&quot; &quot;Krf&quot; ## [12] &quot;Owc&quot; &quot;Dib&quot; &quot;Ctm&quot; &quot;Bnx&quot; &quot;Fbp&quot; &quot;Pvs&quot; &quot;Jeh&quot; &quot;Ghu&quot; &quot;Jzr&quot; &quot;Gky&quot; &quot;Flt&quot; ## [23] &quot;Gqw&quot; &quot;Pud&quot; &quot;Hoe&quot; &quot;Wfk&quot; Сортируем: sort(unsorted_s) # можно базовой функцией ## [1] &quot;Bcg&quot; &quot;Bnx&quot; &quot;Byn&quot; &quot;Caa&quot; &quot;Ctm&quot; &quot;Dib&quot; &quot;Ejq&quot; &quot;Fbp&quot; &quot;Flt&quot; &quot;Fpo&quot; &quot;Ghu&quot; ## [12] &quot;Gky&quot; &quot;Gqw&quot; &quot;Hoe&quot; &quot;Jeh&quot; &quot;Jsz&quot; &quot;Jzr&quot; &quot;Krf&quot; &quot;Owc&quot; &quot;Pud&quot; &quot;Pvs&quot; &quot;Qmj&quot; ## [23] &quot;Rgv&quot; &quot;Rxi&quot; &quot;Wdl&quot; &quot;Wfk&quot; str_sort(unsorted_s) # можно функцией из пакета stringr ## [1] &quot;Bcg&quot; &quot;Bnx&quot; &quot;Byn&quot; &quot;Caa&quot; &quot;Ctm&quot; &quot;Dib&quot; &quot;Ejq&quot; &quot;Fbp&quot; &quot;Flt&quot; &quot;Fpo&quot; &quot;Ghu&quot; ## [12] &quot;Gky&quot; &quot;Gqw&quot; &quot;Hoe&quot; &quot;Jeh&quot; &quot;Jsz&quot; &quot;Jzr&quot; &quot;Krf&quot; &quot;Owc&quot; &quot;Pud&quot; &quot;Pvs&quot; &quot;Qmj&quot; ## [23] &quot;Rgv&quot; &quot;Rxi&quot; &quot;Wdl&quot; &quot;Wfk&quot; Строки сортируются в лексикографическом порядке. Обратите внимание, что порядок сортировки зависит от того, в какой локали мы работаем, то есть от того, алфавит какого языка используется для определения лексикографического порядка: str_sort(c(&quot;э&quot;, &quot;а&quot;, &quot;у&quot;, &quot;i&quot;), locale = &#39;en&#39;) # по умолчанию ## [1] &quot;i&quot; &quot;а&quot; &quot;у&quot; &quot;э&quot; str_sort(c(&quot;э&quot;, &quot;а&quot;, &quot;у&quot;, &quot;i&quot;), locale = &#39;ru&#39;) # русский ## [1] &quot;а&quot; &quot;у&quot; &quot;э&quot; &quot;i&quot; Сортировок существует много разных. Но чем больше у вас данные, тем медленнее будет работать базовый sort(). Поэтому используйте str_sort(). 5.6 Изменение регистра Допусти вы собирали данные онлайн, и у вас было поле ступень образования, в которой респонденты должны быть указать бакалавриат/магистратура/аспирантура. Но по каким-то причинам, разработчик онлайн-формы не подумал, что хорошо бы сделать это поле списком, из котрого можно выбирать, и оставил его как обычное текстовое поле. Теперь у вас в данных есть «бакалавриат», «Бакалавриат» и какой-нибудь «БАкалавриат», то вообще-то одно и то же. Напасти подобного рода можно победить, если привести строки к единому регистру: str_to_lower(c(&quot;Бакалавриат&quot;, &quot;БАКАЛАВРИАТ&quot;, &quot;АСпирантура&quot;, &quot;магистратура&quot;)) ## [1] &quot;бакалавриат&quot; &quot;бакалавриат&quot; &quot;аспирантура&quot; &quot;магистратура&quot; str_to_upper(c(&quot;Бакалавриат&quot;, &quot;БАКАЛАВРИАТ&quot;, &quot;АСпирантура&quot;, &quot;магистратура&quot;)) ## [1] &quot;БАКАЛАВРИАТ&quot; &quot;БАКАЛАВРИАТ&quot; &quot;АСПИРАНТУРА&quot; &quot;МАГИСТРАТУРА&quot; Но при таком способе сбора данных могли возникнуть и другие ошибки, так что лучше задуматься об их предотвращении заранее! 5.7 Поиск подстроки Если нам надо найти какую-то подстроку, то мы можем использоваться функцию str_detect(): str_detect(unsorted_s, &#39;b&#39;) # ищем все элементы, в которых есть маленькая «b» ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [12] FALSE TRUE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE ## [23] FALSE FALSE FALSE FALSE unsorted_s[str_detect(unsorted_s, &#39;b&#39;)] # а вот и сами элементы ## [1] &quot;Dib&quot; &quot;Fbp&quot; Можно подсчитать число вхождений подстроки в строке: str_count(unsorted_s, &#39;a&#39;) ## [1] 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5.8 Изменение строк Раз мы умеем искать подстроку, то, наверное, её можно и как-то изменять. 5.8.1 Выделение подстроки str_sub(unsorted_s, start = 1, end = 2) # по индексам ## [1] &quot;Rx&quot; &quot;Fp&quot; &quot;By&quot; &quot;Js&quot; &quot;Qm&quot; &quot;Wd&quot; &quot;Ej&quot; &quot;Ca&quot; &quot;Rg&quot; &quot;Bc&quot; &quot;Kr&quot; &quot;Ow&quot; &quot;Di&quot; &quot;Ct&quot; ## [15] &quot;Bn&quot; &quot;Fb&quot; &quot;Pv&quot; &quot;Je&quot; &quot;Gh&quot; &quot;Jz&quot; &quot;Gk&quot; &quot;Fl&quot; &quot;Gq&quot; &quot;Pu&quot; &quot;Ho&quot; &quot;Wf&quot; 5.8.2 Замена подстроки str_replace(unsorted_s, pattern = &quot;b&quot;, replacement = &quot;Ц&quot;) ## [1] &quot;Rxi&quot; &quot;Fpo&quot; &quot;Byn&quot; &quot;Jsz&quot; &quot;Qmj&quot; &quot;Wdl&quot; &quot;Ejq&quot; &quot;Caa&quot; &quot;Rgv&quot; &quot;Bcg&quot; &quot;Krf&quot; ## [12] &quot;Owc&quot; &quot;DiЦ&quot; &quot;Ctm&quot; &quot;Bnx&quot; &quot;FЦp&quot; &quot;Pvs&quot; &quot;Jeh&quot; &quot;Ghu&quot; &quot;Jzr&quot; &quot;Gky&quot; &quot;Flt&quot; ## [23] &quot;Gqw&quot; &quot;Pud&quot; &quot;Hoe&quot; &quot;Wfk&quot; 5.8.3 Удаление подстроки str_remove(unsorted_s, &#39;b&#39;) ## [1] &quot;Rxi&quot; &quot;Fpo&quot; &quot;Byn&quot; &quot;Jsz&quot; &quot;Qmj&quot; &quot;Wdl&quot; &quot;Ejq&quot; &quot;Caa&quot; &quot;Rgv&quot; &quot;Bcg&quot; &quot;Krf&quot; ## [12] &quot;Owc&quot; &quot;Di&quot; &quot;Ctm&quot; &quot;Bnx&quot; &quot;Fp&quot; &quot;Pvs&quot; &quot;Jeh&quot; &quot;Ghu&quot; &quot;Jzr&quot; &quot;Gky&quot; &quot;Flt&quot; ## [23] &quot;Gqw&quot; &quot;Pud&quot; &quot;Hoe&quot; &quot;Wfk&quot; 5.8.4 Транслитерация строк stri_trans_general(&quot;русский текст, который должен быть написан латиницей&quot;, &#39;cyrillic-latin&#39;) ## [1] &quot;russkij tekst, kotoryj dolžen bytʹ napisan latinicej&quot; 5.9 Регулярные выражения Но часто нас интересует не конкретная подстрока, и все варианты подстрок, которые имеют определенную структуру. Например, мы хотим найти корректно введенные даты рождения в нашем датасете. Пусть по условию дата должна иметь формат DD.MM.YYYY. И у нас есть вот такой вектор: dates &lt;- c(&#39;21.92.2001&#39;, &#39;01.04.1994&#39;, &#39;5-3-2011&#39;, &#39;6/04/1999&#39;) Ну, так как у нас сейчас совсем игрушечные данные, мы можем смотреть на них глазами и видеть, что у нас в прицнипе три адекватные даты, но записаны по-разному, и одна верного формата, но с 92 месяцем. Чтобы задать структуру паттерна, который мы хотим найти, используются регулярные выражения. Чтобы отображать их работу, будем пользоваться функцией str_view_all(). 5.9.1 Метасимволы Если мы попробуем поискать точки в наших датах, то просто так мы их не найдем: str_view_all(dates, pattern = &quot;.&quot;) Подсветились все символы, так как точка в регулярных выражениях — специальный символ. Поэтому чтобы указать, что нас интересуют собственно точки, нужно их экранировать. str_view_all(dates, pattern = &#39;\\\\.&#39;) Так лучше. Еще к специальным знакам (метасимфолам) относятся $, *, +, ?, ^, [, ], и другие. 5.9.2 Классы знаков В датах нас интересуют цифры, и для них есть специальное обозначение: str_view_all(dates, pattern = &#39;\\\\d&#39;) # ищем цифры str_view_all(dates, pattern = &#39;\\\\D&#39;) # ищем не-цифры Другие классы символов можно найти в следующих примерах: str_view_all(&#39;успешный балбес&#39;, &#39;\\\\s&#39;) # пробелы str_view_all(&#39;успешный балбес&#39;, &#39;\\\\S&#39;) # не-пробелы str_view_all(&#39;верно ведь, что здесь что-то есть&#39;, &#39;\\\\w&#39;) # не пробелы и не знаки препинания str_view_all(&#39;верно ведь, что здесь что-то есть&#39;, &#39;\\\\W&#39;) # пробелы и знаки препинания 5.9.3 Квантификация Можно указать, сколько раз должен встречаться тот или иной символ: ? — ноль или один раз * — ноль или более раз + — один или более раз {n} — n раз Например, найдем все группировки по два числа: str_view_all(dates, &#39;\\\\d{2}&#39;) Итак, теперь мы можем вытащить все корректные даты, которые есть в нашем векторе: str_view_all(dates, &#39;\\\\d{2}\\\\.[01]\\\\d{1}\\\\.\\\\d{4}&#39;) Она получилась всего одна. Но в целом в нашим набором условий это справедливо. Как мы отмечали выше, в нашем векторе в датами есть ещё две даты, который выглядят адекватно, но немного отличаются форматом, в котором они записаны. Подправьте их формат с помощью функций, изученных выше, и измените регулярное выражение так, чтобы оно обнаруживало и их тоже. Подсказка: возможно, вам понадобятся некоторые варианты выше упомянутых функций. Ещё есть numeric() и logical(), например.↩ "]
]

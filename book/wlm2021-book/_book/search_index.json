[
["functions.html", "4 Функции 4.1 Открытый исходный код", " 4 Функции Безусловно, в R дикое множество различных функций. Но иногда нам и их не хватает. И возникает потребность написать свои. Сделать это, на самом деле, вовсе не так сложно, как может показаться. Разберёмся по порядку. Для начала нам нужно осознать, что функция — это объект (такой же объект, как и вектор, матрица или список). И этот объект создается с помощью некоторой функции и имеет имя, которое возникает в результате присваивания. Пока вроде всё знакомо, не так ли? Функция, которая делает функции называется function() (внезапно!). Таким образом выглядит её конструкция: my_func &lt;- function() { } my_func — название нашей новой функции, function() — собственно функция, которая требует на вход аргументы нашей будушей функции, а в фигурных скобках мы будем описывать, как наша функция работает. Теперь нам нужно вспомнить, что функция должна что-то принимать на вход и что-то возвращать в результате работы. На самом деле можно начать с ещё более простого варианта — когда функция даже ничего не принимает на вход, а просто что-то возвращает после выполнения: my_hello &lt;- function() { return(&quot;Hello, world!&quot;) } my_hello() ## [1] &quot;Hello, world!&quot; Функция return() определяет, что будет возвращать наша функция как итог работы. В данном случае она возвращает нам строку &quot;Hello, world!&quot;. Мы можем немного изменить нашу функцию, чтобы она приветствовала не только мир, но и того, кто к ней обратился: my_hello &lt;- function(name) { phrase &lt;- paste0(&quot;Hello, &quot;, name, &quot;!&quot;) return(phrase) } my_hello(&quot;Антон&quot;) ## [1] &quot;Hello, Антон!&quot; Теперь функция приветствует меня и не только — надо всего лишь указать имя того, кому надо сказать «привет». А что будет, если не указать ничего? my_hello() ## Error in paste0(&quot;Hello, &quot;, name, &quot;!&quot;): argument &quot;name&quot; is missing, with no default Функция нам сообщает, что аргумент name является обязательным. Что ж, если мы не хотим такой ошибки, то можем задать значение по умолчанию: my_hello &lt;- function(name = &quot;world&quot;) { phrase &lt;- paste0(&quot;Hello, &quot;, name, &quot;!&quot;) return(phrase) } my_hello(&quot;Антон&quot;) ## [1] &quot;Hello, Антон!&quot; my_hello() ## [1] &quot;Hello, world!&quot; Теперь функция приветствует того, кто указан в её аргументе, а если не указано никого — приветствует весь мир! Pacific function. Мы создавали промежуточную переменную phrase, в которую записывали результат работы функции paste0(), которая занимается соединением строк. Но у нас достаточно простая функция, поэтому нет необходимости занимать лишние строки. Можно упростить её следующим образом: my_hello &lt;- function(name = &quot;world&quot;) { return(paste0(&quot;Hello, &quot;, name, &quot;!&quot;)) } my_hello() ## [1] &quot;Hello, world!&quot; Но можно пойти и ещё дальше! my_hello &lt;- function(name = &quot;world&quot;) { paste0(&quot;Hello, &quot;, name, &quot;!&quot;) } my_hello() ## [1] &quot;Hello, world!&quot; Даже return() не обязателен! Функция просто возвращает результат последней выплоненной команды. Красота! Общий принцип создания и работы функции понятен. Попробуем сделать что-то более интересное. Например, применим какие-то логические конструкции. Напишем простую функцию, которая будет определять, чётное число или нечётное. Чётность определяется остатком от деления на два: если остаток равен нулю, то число чётное, иначе — нечётное. Конечно, в R как и в любом другом языке программирования есть if else statement и for and while loops. Но зачем они нам, если есть ifelse() и векторизация? Чтобы написать такую функцию, нам надо понять, как работает функция ifelse(). Работает она достаточно просто: она требует на вход три аргумента — условие, которое необходимо проверить, значение, которое необходимо вернуть, если условие выполнено, и значение, которое необходимо вернуть, если условие не выполнено. Например, ifelse(2 &gt; 8, &quot;верно&quot;, &quot;неверно&quot;) ## [1] &quot;неверно&quot; ifelse(10 != 2, &quot;верно&quot;, &quot;неверно&quot;) ## [1] &quot;верно&quot; Как мы можем использовать эту функцию для написания кастомной? Вот так:ъ odd_even &lt;- function(x) { ifelse(x %% 2 == 0, &#39;even&#39;, &#39;odd&#39;) } odd_even(2) ## [1] &quot;even&quot; odd_even(3) ## [1] &quot;odd&quot; Но можно написать ещё короче! Всего в одну строку! odd_even &lt;- function(x) ifelse(x %% 2 == 0, &#39;even&#39;, &#39;odd&#39;) odd_even(5) ## [1] &quot;odd&quot; odd_even(8) ## [1] &quot;even&quot; Посчитайте пингвинов! Напишите функцию, которая выводит корректную форму слова «пингвин» в ответ на ввод некоторого числа. penguin(1) ## [1] &quot;1 пингвин&quot; penguin(3) ## [1] &quot;3 пингвина&quot; penguin(10) ## [1] &quot;10 пингвинов&quot; 4.1 Открытый исходный код В R можно не только написать свои функции, но и посмотреть, как написаны другие, то есть увидеть исходный код. Для этого надо написать название функции и выполнить её как команду (без скобок): sd # стандартное отклонение --- корень из дисперсии ## function (x, na.rm = FALSE) ## sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), ## na.rm = na.rm)) ## &lt;bytecode: 0x7fabb3e95230&gt; ## &lt;environment: namespace:stats&gt; lm # функция для построения линейной регрессионной модели ## function (formula, data, subset, weights, na.action, method = &quot;qr&quot;, ## model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, ## contrasts = NULL, offset, ...) ## { ## ret.x &lt;- x ## ret.y &lt;- y ## cl &lt;- match.call() ## mf &lt;- match.call(expand.dots = FALSE) ## m &lt;- match(c(&quot;formula&quot;, &quot;data&quot;, &quot;subset&quot;, &quot;weights&quot;, &quot;na.action&quot;, ## &quot;offset&quot;), names(mf), 0L) ## mf &lt;- mf[c(1L, m)] ## mf$drop.unused.levels &lt;- TRUE ## mf[[1L]] &lt;- quote(stats::model.frame) ## mf &lt;- eval(mf, parent.frame()) ## if (method == &quot;model.frame&quot;) ## return(mf) ## else if (method != &quot;qr&quot;) ## warning(gettextf(&quot;method = &#39;%s&#39; is not supported. Using &#39;qr&#39;&quot;, ## method), domain = NA) ## mt &lt;- attr(mf, &quot;terms&quot;) ## y &lt;- model.response(mf, &quot;numeric&quot;) ## w &lt;- as.vector(model.weights(mf)) ## if (!is.null(w) &amp;&amp; !is.numeric(w)) ## stop(&quot;&#39;weights&#39; must be a numeric vector&quot;) ## offset &lt;- model.offset(mf) ## mlm &lt;- is.matrix(y) ## ny &lt;- if (mlm) ## nrow(y) ## else length(y) ## if (!is.null(offset)) { ## if (!mlm) ## offset &lt;- as.vector(offset) ## if (NROW(offset) != ny) ## stop(gettextf(&quot;number of offsets is %d, should equal %d (number of observations)&quot;, ## NROW(offset), ny), domain = NA) ## } ## if (is.empty.model(mt)) { ## x &lt;- NULL ## z &lt;- list(coefficients = if (mlm) matrix(NA_real_, 0, ## ncol(y)) else numeric(), residuals = y, fitted.values = 0 * ## y, weights = w, rank = 0L, df.residual = if (!is.null(w)) sum(w != ## 0) else ny) ## if (!is.null(offset)) { ## z$fitted.values &lt;- offset ## z$residuals &lt;- y - offset ## } ## } ## else { ## x &lt;- model.matrix(mt, mf, contrasts) ## z &lt;- if (is.null(w)) ## lm.fit(x, y, offset = offset, singular.ok = singular.ok, ## ...) ## else lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok, ## ...) ## } ## class(z) &lt;- c(if (mlm) &quot;mlm&quot;, &quot;lm&quot;) ## z$na.action &lt;- attr(mf, &quot;na.action&quot;) ## z$offset &lt;- offset ## z$contrasts &lt;- attr(x, &quot;contrasts&quot;) ## z$xlevels &lt;- .getXlevels(mt, mf) ## z$call &lt;- cl ## z$terms &lt;- mt ## if (model) ## z$model &lt;- mf ## if (ret.x) ## z$x &lt;- x ## if (ret.y) ## z$y &lt;- y ## if (!qr) ## z$qr &lt;- NULL ## z ## } ## &lt;bytecode: 0x7fabb0295b60&gt; ## &lt;environment: namespace:stats&gt; "]
]

[["структуры-данных.html", "3 Структуры данных 3.1 Векторы 3.2 Матрицы 3.3 Списки 3.4 Датафреймы", " 3 Структуры данных С тем, какие существуют данные, мы разобрались. Теперь надо понять, как мы их можем организовать. 3.1 Векторы Простейший способ организации данных — это вектор. Казалось бы, мы знаем, что вектор — это направленный отрезок. Безусловно, это так — в рамках Евклидовой геометрии, которую мы в давнем прошлом учили. Однако это не единственный способ смотреть на вещи. С точки зрения структур данных, вектор — это одномерный массив, а если по-русски, то набор элементов одного типа (например, чисел). Эти два представления, на самом деле, не противоречат друг другу. Геометрически, как мы сказали, вектор — это направленный отрезок. Он задаётся через координаты начала и конца. Если мы условимся всегда начинать вектор из начала координат — то есть будет считать равными все векторы, которые имеют одинаковую длину и одинаковое направление1 — то мы сможем задавать вектор только через координаты его конца. В случае двумерного пространства вектор будет однозначно задаваться парой чисел \\((x, y)\\), в случае трёхмерного — тройкой чисел \\((x,y,z)\\), а в случае \\(n\\)-мерного пространства — набором чисел \\((x_1, x_2, x_3, \\dots, x_n)\\). Чтобы создать вектор в R надо воспользоваться функцией c(). Она принимает неограниченное количесво аргументов, которые объединяет в вектор. В вектор можно объединить элементы только одного типа. v &lt;- c(1,2,3,5,6,7) Сохраним получившийся числовой вектор в переменную v. Присваивание векторов ничем не отличается от присваивания чисел, во-первых, потому что в R нет скаляров, и все числа — это векторы типа numeric длиной 1, а во-вторых, потому что и число, и вектор, и другие структуры данных (и даже функции!) — всё это объекты. А assignment — не что иное, как присваивание имени некоторому объекту, и нет разницы, что мы называем — число, матрицу, список, датафрейм или функцию. 3.1.1 Coercion [part two] Взбунтуемся, и объеденим в один вектор разные типы данных: v0 &lt;- c(1, 2, TRUE, FALSE) v0 ## [1] 1 2 1 0 Бунт не удался — вектор всё равно был создан. Но что произошло? С приведением типов мы уже сталкивались, когда пытались складывать логические константы. Аналогично R действовал и здесь: есть задача создать вектор но на выход функции поступили данные различных типов придётся сделать так, чтобы тип был всё-таки один numeric к logical однозначно привести сложно (что есть 2 — TRUE или FALSE?) logical к numeric приводится очень хорошо и красиво (TRUE — 1, FALSE — 0) после приведения типов можно выполнить команду создания вектора. А всё-таки: что есть 2? TRUE или FALSE? Выясните, воспользовавшись функциями isTRUE() и isFALSE(). А будет ли работать (и как именно) ручное приведение numeric к logical? С помощью функции as.logical() приведите числа 0, 1, 2 и -1 к логическому типу. Сделаем вектор из полного салата — добавим сторовые значения: v0 &lt;- c(1, 2, TRUE, FALSE, &#39;text&#39;, &#39;string&#39;) v0 ## [1] &quot;1&quot; &quot;2&quot; &quot;TRUE&quot; &quot;FALSE&quot; &quot;text&quot; &quot;string&quot; Наблюдаем, что все свелось к типу character, что вполне ожидаемо, так как 2 в \"2\" превращается однозначно, а вот в какое число (или логическую константу) превратить \"string\", не очень понятно. Как отработает следующая конструкция? v0 &lt;- c(c(1, 2, TRUE), FALSE, &#39;text&#39;, &#39;string&#39;) И почему именно так? Собственно, можно вывести иерархию приведения типов: logical &lt; integer &lt; numeric &lt; complex &lt; character 3.1.2 Генерация числовых последовательностей Создавать руками вектора — это, конечно, радостно и приятно, но не очень юзабельно. На практике часто возникает потребность сгенерировать определенную числовую последовательность. Например, у вас есть опросниковые данные, из которых необходимо удалить персональные данные, но при этом сохранить возможность соотнести персональные данные и результаты анализа по каждому респонденту — вам нужно сгенерировать переменную ID. Вам поможет оператор :, который генерирует последовательность в заданных пределах с шагом 1: 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 15:0 ## [1] 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 Если вам нужна последовательно с другим шагом, например, 0.5, то подойдет функция seq(): seq(from = 1, to = 10, by = 0.5) # задаём шаг последовательности ## [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5 8.0 ## [16] 8.5 9.0 9.5 10.0 seq(0, -6, -1.5) # или без указания названий аргументов ## [1] 0.0 -1.5 -3.0 -4.5 -6.0 seq(from = 5, to = 30, length.out = 20) # задаём длину последовательности ## [1] 5.000000 6.315789 7.631579 8.947368 10.263158 11.578947 12.894737 ## [8] 14.210526 15.526316 16.842105 18.157895 19.473684 20.789474 22.105263 ## [15] 23.421053 24.736842 26.052632 27.368421 28.684211 30.000000 Допустим, у вас есть данные (пусть выборка будет 15 человек), в которых каждые две строки относятся к одному респонденту, но к двум различным экспериментальным условиям (экспериментальному и контрольному). Тогда можно сделать такие переменные: rep(1:15, each = 2) # для id ## [1] 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 11 12 12 13 ## [26] 13 14 14 15 15 rep(c(&#39;exp&#39;, &#39;control&#39;), times = 15) # для обозначения условия ## [1] &quot;exp&quot; &quot;control&quot; &quot;exp&quot; &quot;control&quot; &quot;exp&quot; &quot;control&quot; &quot;exp&quot; ## [8] &quot;control&quot; &quot;exp&quot; &quot;control&quot; &quot;exp&quot; &quot;control&quot; &quot;exp&quot; &quot;control&quot; ## [15] &quot;exp&quot; &quot;control&quot; &quot;exp&quot; &quot;control&quot; &quot;exp&quot; &quot;control&quot; &quot;exp&quot; ## [22] &quot;control&quot; &quot;exp&quot; &quot;control&quot; &quot;exp&quot; &quot;control&quot; &quot;exp&quot; &quot;control&quot; ## [29] &quot;exp&quot; &quot;control&quot; Сгенерируйте последовательность от 106 до 124 с шагом 4, в которой каждый элемент будет повторяться подряд три раза. ## [1] 106 106 106 110 110 110 114 114 114 118 118 118 122 122 122 Также можно сгенерировать случайную последовательность чисел (например, для того, чтобы использовать её при сабсете случайной подвыборки данных): sample(x = 1:30, size = 15) ## [1] 5 10 1 8 11 2 21 25 15 12 17 30 4 20 29 По умолчанию функция sample() генерирует случайную последовательность с учетом того, что выпадение каждого числа равновероятно. Как изменить это условие? Сгенерируйте случайную последователность из 30 чисел от 1 до 10 при условии, что единица выпадает в два раза чаще, чем все остальные числа. Чтобы результат получился такой же, как ниже, перед выполнением команды sample(...) выполните команду: set.seed(69) ## [1] 6 9 4 10 5 10 1 9 1 1 10 8 2 3 3 3 1 7 1 9 5 1 4 8 1 ## [26] 3 4 7 1 8 3.1.3 Операции с векторами Операции, которые можно выполнять над векторами зависят от типа данных, которые содержатся в векторе. Чаще всего мы будем работать с числовыми векторами, поэтому разберем подробно именно их. Пусть у нас будет два вектора: set.seed(42) # задаём положение для датчика случайных чисел v1 &lt;- sample(1:100, 20) v2 &lt;- sample(-50:100, 20) Над векторами можно выполнять арифметические операции: v1 + v2 ## [1] 56 56 -2 66 110 200 132 9 88 147 78 -27 74 66 -4 110 115 70 -14 ## [20] 154 v1 - v2 ## [1] 42 74 52 82 -74 0 -38 39 54 31 -4 67 -22 -60 86 -56 -43 -60 82 ## [20] 20 v1 * v2 ## [1] 343 -585 -675 -592 1656 10000 3995 -360 1207 5162 1517 -940 ## [13] 1248 189 -1845 2241 2844 325 -1632 5829 v1 / v2 ## [1] 7.00000000 -7.22222222 -0.92592593 -9.25000000 0.19565217 1.00000000 ## [7] 0.55294118 -1.60000000 4.17647059 1.53448276 0.90243902 -0.42553191 ## [13] 0.54166667 0.04761905 -0.91111111 0.32530120 0.45569620 0.07692308 ## [19] -0.70833333 1.29850746 Они выполняются поэлементно, то есть соответсвующие элементы двух векторов складываются (вычитаются, умножаются, делятся), и в результате получается новый вектор. Кроме того, векторы можно поэлементно сравнивать: v1 &lt; v2 ## [1] FALSE FALSE FALSE FALSE TRUE FALSE TRUE FALSE FALSE FALSE TRUE FALSE ## [13] TRUE TRUE FALSE TRUE TRUE TRUE FALSE FALSE v1 == v2 ## [1] FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE ## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE v2 &lt;= v1 ## [1] TRUE TRUE TRUE TRUE FALSE TRUE FALSE TRUE TRUE TRUE FALSE TRUE ## [13] FALSE FALSE TRUE FALSE FALSE FALSE TRUE TRUE Также к вектору можно применять и функции: sin(v1) ## [1] -0.9537527 0.8268287 -0.1323518 -0.9851463 -0.7509872 -0.5063656 ## [7] 0.1235731 -0.9055784 0.9510547 0.8600694 -0.6435381 0.9129453 ## [13] 0.7625585 0.1411200 -0.1586227 0.9563759 -0.9917789 -0.9589243 ## [19] 0.5290827 -0.8218178 log(v1) ## [1] 3.891820 4.174387 3.218876 4.304065 2.890372 4.605170 3.850148 3.178054 ## [9] 4.262680 4.488636 3.610918 2.995732 3.258097 1.098612 3.713572 3.295837 ## [17] 3.583519 1.609438 3.526361 4.465908 exp(v2) ## [1] 1.096633e+03 1.234098e-04 1.879529e-12 3.354626e-04 9.017628e+39 ## [6] 2.688117e+43 8.223013e+36 3.059023e-07 2.415495e+07 1.545539e+25 ## [11] 6.398435e+17 3.873998e-21 7.016736e+20 2.293783e+27 2.862519e-20 ## [16] 1.112864e+36 2.038281e+34 1.694889e+28 1.425164e-21 1.252363e+29 Можно применять несколько функций подряд: log(abs(v2)) ## [1] 1.945910 2.197225 3.295837 2.079442 4.521789 4.605170 4.442651 2.708050 ## [9] 2.833213 4.060443 3.713572 3.850148 3.871201 4.143135 3.806662 4.418841 ## [17] 4.369448 4.174387 3.871201 4.204693 Большинство арифметических функций выполняется поэлементно, однако существуют такие, которые поэлементно не могут быть выполнены, например сумма по вектору: sum(v1) ## [1] 878 Или функция, которая вычисляет длину вектора (в смысле колиичества элементов в нём): length(v2) ## [1] 20 3.1.4 Recycling 3.1.5 Индексация векторов 3.1.6 NA, NaN, NULL 3.2 Матрицы 3.3 Списки 3.4 Датафреймы Такие векторы называются свободными.↩︎ "]]

# Предобработка данных. Концепция tidy data {#tidy}

Мы приступаем к одной из ключевых тем курса ---  предобработка данных. И это тему мы будем осваивать c помощью семейства пакетов `tidyverse`.

## `tidyverse`

Чтобы преуспеть в этом деле, нам надо поставить себе на машину пакет с пакетами:

```{r, eval=FALSE}
install.packages('tidyverse', dependencies = TRUE)
```

Какие пакеты внутри пакета?

* `ggplot2` --- для визуализации
* `tibble` --- для работы с тибблами (как датафрейм, только лучше)
* `tidyr` --- для формата *tidy data*
* `readr` --- для чтения файлов
* `purrr` --- для функционального программирования
* `dplyr` --- для преобразования данных
* `stringr` --- для работы со строковыми переменными (с ним мы уже виделись)
* `forcats` --- для работы с факторными переменными

Кроме этого джентельменского набора нам еще пригодится пакет `readxl`, и которого мы будем брать функции для чтения файлов `.xls` и `.xlsx`.

Подключаем пакеты к сессии:

```{r}
library(tidyverse)
```

Нам написали верси пакетов, которые мы подгрузили, а также обозначили ряд конфликтов, которые произошли --- базовые функции перекрылись функциями из внешних пакетов[^1]. Но это всё можно игнорировать.


## Импорт данных

Мы уже говорили с вами, что для импорта данных есть generic-функция `read.table()` и ещё ряд функций, которые адаптированы под конкретные форматы данных (`read.tsv()`, `read.csv()`). Это всё хорошо и приятно, но мы будем пользоваться их сестами-близнецами из пакета `readr`:

```{r, eval=FALSE}
read_csv("path/to/file") # для чтения классических csv-файлов
read_csv2("path/to/file") # для чтения csv-файлов с разделителем точка в запятой
read_delim("path/to/file", delim = "...") # для чтения файлов с любым разделителем
```

Эти функции, как и базовые, умеют открывать файлы

* *только по имени* (если файл лежит в рабочей директории)
* *по относительному пути* (если файл лежит в подпапке рабочей директории)
* *по абсолютному пути* (когда мы прописываем путь к файлу от корня)
* *напрямую из интернета* (при наличии интернет-соединения)

Каков профит? Во-первых, они работают быстрее, но на наших объемах данных мы этого, скорее всего, не заметим. А во-вторых, они считывают данные не в датафрейм, а в `tibble`, что очень радостно и приятно, если осознать, что `tibble` есть такое.


## `tibble`

Мы уже умеет работать с датафреймами, однако мы пока не сталкивались с некоторыми их особенностями. В частности, если мы попытаемся создать новую переменную на основе имеющейся прям при создании датафрейма, случится ошибка. Пусть у нас есть колонка с возрастом респондентов, и мы хотим сделать новый переменную, которая будет задавать контрастные группы:

```{r, error=TRUE}
data.frame(age = sample(18:60, size = 30),
           group = ifelse(age > 40, 'old',
                          ifelse(age < 25, 'young', 'middle')))
```

R говорит нам, что переменная `age` ещё не создана, что в целом достаточно справедливо. Мы можем эту напасть побороть, сначала создав переменную `age`, а затем сделать новую переменную `group` через присваивание… но чёт лень…

Лучше воспользуемся мощностями `tibble`:

```{r}
tibble(age = sample(18:60, size = 30),
           group = ifelse(age > 40, 'old',
                          ifelse(age < 25, 'young', 'middle')))
```

Роскошно!

Может показаться, что это достаточно незначительно преимущество. В целом, да --- `tibble` и `data.frame` практически одно и то же. Однако, во-первых, стоит помнить, что функции из `tidyverse` всегда возвращают `tibble`, а во-вторых, когда мы познаем всю мощь ~~тёмной стороны~~ [функции `mutate()`](#mutate), мы осознаем полезность фичи исползования переменных «по ходу событий».


## Грузим много данных

На самом деле, не так уж и много. Просто в этот раз они располагаются в разных файлах. Нам понадобится [вот этот архив](https://drive.google.com/uc?export=download&id=1pEfS2MH6t3scZ-tp7XSCfbOHpcvNKwcR).

Его надо (1) разархивировать, и (2) положить всю получившуюся папку в нашу папку `data` в директории курса.

Кстати, чтобы отобразить список файлов, которые лежат в некоторой папке есть команда `dir()` (по умолчанию отображает содержимое рабочей директории):

```{r}
dir(path = 'data/data_sharexp')
```

Функция возвращает строковый вектор, поэтому чтобы узнать количество файлов в директории, можно сделать следующее:

```{r}
length(dir(path = 'data/data_sharexp'))
```

У нас есть 21 файл. Это данные поведенческого эксперимента, в котором пользователи платформ iOS и Android искали иконки share обеих платформ среди других иконок. Судя по тому, как названы файлы, у нас есть 20 Excel-ек с данными и файл `targetpositions.xlsx`, в котором содержатся координаты целевых стимулов.

Загрузим один файл, и посмотрим, что получится. Нам будет нужен второй лист, так как данные основной серии записаны на нём:

```{r}
raw01 <- readxl::read_xlsx('data/data_sharexp/01.xlsx', 2)
str(raw01)
```

Данные выглядят адекватно, но --- куча переменных. Нам явно нужны не все.

## Сабсет данных

Кто знаком с аутпутами PsychoPy, тот опознает смысл названий переменных. Кто не знаком с аутпутами PsychoPy --- не страшно. Нам нужны следующие переменные:

* независимые переменные:
  - `trialtype` --- тип пробы (`tray`, `dots`, `both`)
  - `setsize` --- количество стимулов в пробе (`8`, `12`, `16`)
* зависимые переменные (или те переменные, на основе которых мы их посчитаем):
  - `mouse_main1.time_raw` --- время первого клика (мс)
  - `mouse_main1.x_raw` --- координата `x` первого клика
  - `mouse_main1.y_raw` --- координата `y` первого клика
  - `mouse_main2.time_raw` --- время второго клика (мс)
  - `mouse_main2.x_raw` --- координата `x` второго клика
  - `mouse_main2.y_raw` --- координата `y` второго клика
* `numtrial` --- номер пробы в исходном файле с координатами (пригодится нам позднее)

Давайте их вытаскивать.

### ` %>% ` {#pipe}

Для того, чтобы это делать элегантно и красиво, нам надо познакомиться с ключевой особенностью синтаксиса `tidyverse`. На секунду отвлечемся от данных и представим, что нам надо посчитать вот такое дикое выражение:

```{r}
sqrt(abs(log(abs(round(sin(1 / cos(3)), 2)), 3)))
```

Запись верная, но читать это совершенно невозможно. Чтобы решить этот вопрос, нам на помощь приходит *pipe* --- специальный оператор, чем-то напоминающий вилосипедик ` %>% `.

Работает он очень просто: он передаёт то, что от него стоит слева, в функцию, которая стоит от него справа, в качестве первого аргумента. То есть эти две команды

```{r}
sum(3, 4)
3 %>% sum(4)
```

содержательно абсолютно идентичны. Только записываются немного по-разному.

Если переписать выражение выше с помощью *pipes*, то получится очень понятный «конвейер»:

```{r}
3 %>% cos() %>% 
  `/`(1, .) %>% 
  sin() %>% 
  round(2) %>% 
  abs() %>% 
  log(3) %>% 
  abs() %>% 
  sqrt()
```

Теперь отчетливо видна последовательность функций, которые мы совершали, и более того, если что-то можно не так, то можно запросто откопать баг, выполнив только часть кода до определенного пайпа. Во второй строчке нам встретилась особенность --- если нам нужно передать объект слева в функцию справа, но не первым аргументом, надо указать его позицию с помощью точки[^2].

Теперь мы готовы идти в бой!

### `select()`

Фнукция `select()` выбирает опредлённые колонки из нашего датасета. Работает очень просто:

```{r}
raw01 %>% select(trialtype,
                 setsize,
                 numtrial,
                 mouse_main1.time_raw,
                 mouse_main1.x_raw,
                 mouse_main1.y_raw,
                 mouse_main2.time_raw,
                 mouse_main2.x_raw,
                 mouse_main2.y_raw)
```

Кайф! Только пока мы наш новый тиббл никуда не записали. Но, подождём --- мы ещё не закончили.

### `rename()`

Мы будем теперь практически всегда обращаться к колонкам по имени, поэтому полезно будет их сразу переименовать во что-то более юзабельное. Функци `rename()` занимается именно этим. В качестве её аргументов надо перечислить *новые имена колонок* и *к каким колонкам они относятся*:

```{r}
raw01 %>% select(trialtype,
                 setsize,
                 numtrial,
                 mouse_main1.time_raw,
                 mouse_main1.x_raw,
                 mouse_main1.y_raw,
                 mouse_main2.time_raw,
                 mouse_main2.x_raw,
                 mouse_main2.y_raw) %>% 
  rename(time1 = mouse_main1.time_raw,
         click1x = mouse_main1.x_raw,
         click1y = mouse_main1.y_raw,
         time2 = mouse_main2.time_raw,
         click2x = mouse_main2.x_raw,
         click2y = mouse_main2.y_raw)
```

Красuво! Заметьте, что мы продолжаем наш «конвейер».



### `slice()`

Посмотрим, если строки с пропущенными значениями. Прям тут, не отходя от конвейера:

```{r}
raw01 %>% select(trialtype,
                 setsize,
                 numtrial,
                 mouse_main1.time_raw,
                 mouse_main1.x_raw,
                 mouse_main1.y_raw,
                 mouse_main2.time_raw,
                 mouse_main2.x_raw,
                 mouse_main2.y_raw) %>% 
  rename(time1 = mouse_main1.time_raw,
         click1x = mouse_main1.x_raw,
         click1y = mouse_main1.y_raw,
         time2 = mouse_main2.time_raw,
         click2x = mouse_main2.x_raw,
         click2y = mouse_main2.y_raw) %>% 
  sapply(is.na) %>% apply(2, sum)
```

В каждой переменной есть по девять пропусков. Чтобы понять, что это за пропуски, надо немного знать о том, как PsychoPy записывает данные. После того, как он написал в Excel все экспериментальные данные, он в самом низу дописывает соцдем, который испытуемые заполняют в самом начале эксперимента.

Вот эта штука:

<center>
<img src="img/socdem_psychopy.png">
</center>

Как раз девять строчек --- они нам и делают пропущенные значения. Так как они идут после всех наших данные, то мы можем просто *«отрезать»* этот кусок таблицы:

```{r}
raw01 %>% select(trialtype,
                 setsize,
                 numtrial,
                 mouse_main1.time_raw,
                 mouse_main1.x_raw,
                 mouse_main1.y_raw,
                 mouse_main2.time_raw,
                 mouse_main2.x_raw,
                 mouse_main2.y_raw) %>% 
  rename(time1 = mouse_main1.time_raw,
         click1x = mouse_main1.x_raw,
         click1y = mouse_main1.y_raw,
         time2 = mouse_main2.time_raw,
         click2x = mouse_main2.x_raw,
         click2y = mouse_main2.y_raw) %>% 
  slice(1:450) # мы знаем, что у нас было 450 экспериментальных проб
```

Можно перепроверить, не осталось ли у нас пропущенных значений, с помощью той же строчки, что и в предыдущем чанке.


### `filter()`

Для анализа нам будут нужны не все пробы, а только из экспериметальных условий `tray` и `dots`. А как мы помним из описания переменные, экспериметальных условий было три --- `tray`, `dots` и `both`. Надо *отфильтровать* это третье условие. Изи:

```{r}
raw01 %>% select(trialtype,
                 setsize,
                 numtrial,
                 mouse_main1.time_raw,
                 mouse_main1.x_raw,
                 mouse_main1.y_raw,
                 mouse_main2.time_raw,
                 mouse_main2.x_raw,
                 mouse_main2.y_raw) %>% 
  rename(time1 = mouse_main1.time_raw,
         click1x = mouse_main1.x_raw,
         click1y = mouse_main1.y_raw,
         time2 = mouse_main2.time_raw,
         click2x = mouse_main2.x_raw,
         click2y = mouse_main2.y_raw) %>% 
  slice(1:450) %>% 
  filter(trialtype != 'both')
```

Вот теперь хорошо и красиво! Можно сохранить в новый объект!

```{r}
raw01 %>% select(trialtype,
                 setsize,
                 numtrial,
                 mouse_main1.time_raw,
                 mouse_main1.x_raw,
                 mouse_main1.y_raw,
                 mouse_main2.time_raw,
                 mouse_main2.x_raw,
                 mouse_main2.y_raw) %>% 
  rename(time1 = mouse_main1.time_raw,
         click1x = mouse_main1.x_raw,
         click1y = mouse_main1.y_raw,
         time2 = mouse_main2.time_raw,
         click2x = mouse_main2.x_raw,
         click2y = mouse_main2.y_raw) %>% 
  slice(1:450) %>% 
  filter(trialtype != 'both') -> d01
str(d01)
```

Да, assignment слева направо тоже работает, и в данном случае это хорошо согласуется с логикой пайпов.

Всё хорошо, но в данном датасете нам не хватает двух вещей --- `id` нашего испытуемого. Зачем? Во-первых, он может быть нужен для некоторых видов анализа, а кроме того, он нам пригодится чуть позже, когда мы будем возиться ещё с одной историей.


## `mutate()` {#mutate}

Функция `mutate()` позволяет делать дикую кучу всего, но пока познакомимся с логикой её работы.

```{r}
d01 %>% mutate(id = 1) %>% str()
```

То есть она просто создаёт нам новую переменную. Круто же.

Не забудем перезаписать нас тиббл:

```{r}
d01 %>% mutate(id = 1) -> d01
```

## Догрузим остальные данные

Вернёмся немного назад и вспомним, что у нас не один файл данных, а *двадцать*. При этом --- так как это автоматически записанные файлы --- они одинаково устроены. То есть, чтобы их предобработать, нам надо будет двадцать раз повторить один и те же операции. Ну, не будем же мы двадцать раз копировать тот абзац кода, который мы написали!

Конечно, нет. Мы завернем его в функцию.

```{r}
import_data <- function(x, id) {
  library(tidyr)
  library(readr)
  readxl::read_excel(x, 2) %>%
    select(
      trialtype,
      setsize,
      numtrial,
      mouse_main1.time_raw,
      mouse_main1.x_raw,
      mouse_main1.y_raw,
      mouse_main2.time_raw,
      mouse_main2.x_raw,
      mouse_main2.y_raw
    ) %>%
    rename(
      time1 = mouse_main1.time_raw,
      click1x = mouse_main1.x_raw,
      click1y = mouse_main1.y_raw,
      time2 = mouse_main2.time_raw,
      click2x = mouse_main2.x_raw,
      click2y = mouse_main2.y_raw
    ) %>%
    slice(1:450) %>%
    filter(trialtype != 'both') %>%
    mutate(id = id) %>%
    return()
}
```

Роскошь! Теперь у нас есть функция, которая грузит данные и сразу их предобрабатывает! Ну, не чудо ли!

Вот только эта функция у нас работает на одном датасете, то есть чтобы загрузить все двадцать, нам всё равно придется написать 20 одинаковых строк кода. Нерадужное мероприятие.

Но мы сделаем по-другому.


### Соединение датафреймов I

Наша конечная цель --- получить единый датасет, в котором будут содержаться все наблюдения по всем испытуемым. Мы уже добились того, что наша функция возвращает нам ровный и красивый tidy `tibble`. Нам осталось лишь поставить их друг на друга, чтобы получить то, что нам нужно.


#### `bind_...()`

Слепить два тиббла можно либо по столбцам, либо по строкам. Этим занимаются две функции: `bind_cols()` и `bind_rows()` соответственно. Что происходит, когда количество строк / столбцов одинаковое --- понятно: таблички просто слепляются. А вот если это не так:

```{r, error=TRUE}
tbl1 <- as_tibble(matrix(1:12, nrow = 3))
tbl2 <- as_tibble(matrix(1:12, ncol = 3))

bind_rows(tbl1, tbl2)
bind_cols(tbl1, tbl2)
```

Вот так вот.

В нашем случае всё прозаично --- нам просто нужно поставить 20 тибблов друг на друга. Нам --- единственный раз! --- понадобиться цикл.

```{r}
share <- tibble() # заглушка для первой итерации
files <- paste0('data/data_sharexp/', dir('data/data_sharexp')[-21]) # вектор с названиями файлов

for (i in 1:20) {
  import_data(files[i], i) %>% bind_rows(share, .) -> share
}
```

Посмотрим, что получилось:

```{r}
str(share)
```

Выглядит вроде верно.

```{r}
unique(share$id)
table(share$trialtype, share$id)
```

Вроде всё ровно. Чилл.


## Сортировка

### `sort()`

Иногда нам может потребоваться отсортировать наши данные. Как сортировать отдельные векторы, мы уже знаем:

```{r}
sort(share$numtrial)
```

А если весь датасет?


### `arrange()`

Тогда вот так:

```{r}
share %>% arrange(numtrial)
```

Или по двум переменным сразу:

```{r}
share %>% arrange(numtrial, id)
```

В данном случае получилось то же самое, так как мы присоединяли данные испытуемых последовательно с увеличивая `id`.


### `distinct()`

Можно вывести уникальные сочетания по двум переменным:

```{r}
share %>% distinct(trialtype, setsize)
```

Тут все достаточно ожидаемо --- (квази)эксперимент всё-таки.

> Так, погодите! А если это квазиэксперимент, то где же *квазиНП*? Она точно была! В описании эксперимента фигурировала используемая платформа смартфона!

> Спокойно. Ща всё будет.


## Соединение датафреймов II

Данные о том, смартфон на какой платформе использует испытуемый, были записаны в отдельный датасет. Он [вот тут]().

```{r, include=FALSE}
write_csv(tibble(id = 1:20,
                         platform = c(
                           'ios',
                           'ios',
                           'ios',
                           'andr',
                           'ios',
                           'andr',
                           'andr',
                           'andr',
                           'ios',
                           'andr',
                           'andr',
                           'andr',
                           'ios',
                           'ios',
                           'andr',
                           'andr',
                           'ios',
                           'andr',
                           'ios',
                           'ios')), file = 'data/share_platform.csv')
```




### `..._join()`




## Группировка и аггрегация данных

### `group_by()` & `ungroup()`

### `summarize()`, `n()`, `count()`



## Широкий и длинный формат

### `pivot_longer()` & `pivot_wider()`








[^1]: Помните разговор о [пространстве имен](https://angelgardt.github.io/hseuxlab-wlm2021/book/realdata.html#fn3)?
[^2]: Чтобы полностью понять вторую строку, надо вспомнить, что оператор деления `/` --- это тоже функция, которая принимает в себя два аргумента. В данном случае нам надо поделить единицу на косинус, значит косинус должен идти вторым.

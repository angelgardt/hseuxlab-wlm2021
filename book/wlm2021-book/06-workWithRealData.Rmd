# Работа с реальными данными {#realdata}

Итак, мы приступаем к самому интересному и самому важному разделу первого блока! Мы будем тренироваться на данных о фильма и сериалах Netflix.


## Рабочая директория

Раз мы хотим работать в данными, надо их откуда-то взять. Скачайте датасет [по этой ссылке](https://drive.google.com/uc?export=download&id=1P1liIRyPrYnmFmoAFUDJthki_dWhalzF).

**Датасетом** мы будем называть любой набор данных, который у нас есть.

Мы уже говорили о рабочей директории и проектах в самом начале курса. Немного вспомним эту тему. Мы накапливаем много различных файлов (скрипты, файлы сырых данных данных, файлы предобработанны данных, файл объектов из рабочего пространства, графики, результаты анализа…) в процессе анализа данных, и это необходимо каким-то образом систематизировать.

Есть **рабочая директория** --- это папка, в которую смотрит R во время работы. Что это за папка можно узнать через команду:

```{r}
getwd() # get working directory
```

У меня он смотрел вот в эту папку, у вас, скорее всего, будет что-то типа `C://users/имя_пользователя` или `/Users/имя_пользователя`, что указывает на папку пользователя по умолчанию.

Можно установить другую рабочую директорию с помощью команды `setwd()`:

```{r, eval=FALSE}
setwd("/Users/antonangelgardt/R")
```

Теперь он будет смотреть в папку `R`, которая лежит в дефолтной папке пользователя. Такой способ достаточно удобен, однако можно сделать ещё лучше --- создать проект (*Project*).

> Кто-то любит работать в проектах, кто-то нет --- дело вкуса. Мне это нравится, даже если вам не понравится. Простите, если мы вдруг не сойдёмся во вкусах, но, повторюсь, это нравится мне, сугубо, лично… Поэтому я буду про это рассказывать и рекламировать.

Зайдите в `File → New Project…`. У вас откроется такое окно:

![](img/proj1.png)

Выберите `New Directory`, затем еще раз `New Project`:

![](img/proj2.png)

Откроется вот это:

![](img/proj3.png)

В `Directory name` указываем название нашей папки, во втором поле указываем путь к той папке, в которой будет лежать создаваемая папка. Нажимаем `Create Project`, после чего R перезапускает сессию, и открывается привычное окно. Однако в верхнем правом углу R теперь указано название проекта, в котором мы работаем.


> Если вы уже это сделали в начале курса, то пропустите это задание.

<img class="taskimg" src="img/task.png">
<div class="task">
Создайте проект для нашего курса.

1. Откройте `File → New Project…`
2. Выберите `New Directory → New Project`
3. Назовите новую директорию `hseuxlab-wlm2021`
4. Задайте расположение внутри папки пользователя системы
5. Создайте новый скрипт и скопируйте туда следующий код:

```
print("Hello, World of Linear Models!")
```

6. Сохраните скрипт нажатием `Ctrl` + `S` (`Cmd` + `S`)
</div>

Теперь при работе в рамках курса мы будем запускать проект и работать в нём, чтобы ничего не запуталось.


Много ли это приносит профита? Ну, не так уж и много… По сути, что открыть проект, что выполнить `setwd("пусть_к_папке")` --- примерно одно и то же. Вот только строку кода можно забыть запустить после открытия скрипта, а если мы запустили проект, мы уверены, что у нас все автоматически настроилось и ошибок не будет.


> Если вы уже это сделали в начале курса, то пропустите это задание.

<img class="taskimg" src="img/task.png">
<div class="task">
Откройте директорию (папку) проекта курса и создайте в ней несколько папок. Они нам понадобятся для структурирования нашего пространства в процессе курса, потому что файлов будет много. Кроме того, будем постепенно привыкать к тому, чтобы наше рабочее пространство было чистым и опрятным.

Нам понадобятся следующие папки:

* `scripts` для хранения скриптовых файлов
* `data` для хранения файлов данных
* `figures`, чтобы выгружать графики

Потом мы сможем дополнить их другими папками, если нам таковые понадобятся, а также создать более мелкие подразделы внутри созданных папок.
</div>

> Дальнейший разговор будет вестись с учетом того, что вы работаете в созданном проекте или задали рабочую директорию через `setwd()`, а также у вас созданы папки `scripts`, `data` и `figures` внутри папки нашего курса.

## Импорт данных

Окей, файл с данными у нас есть. Теперь наша задача его как-то загрузить в R, чтобы мы могли с ним работать. Вариантов существует несколько. Разберём сначала следующий.

* переложите [скачанный файл](https://drive.google.com/uc?export=download&id=1P1liIRyPrYnmFmoAFUDJthki_dWhalzF) из «Загрузок» в папку `data`
* обратите внимание на расширение этого файла: `netflix_title.csv`

Такие файлы можно *прочитать* с помощью функции `read.csv()`. В аргументах это функции надо указать файл, который надо прочитать (а также путь к нему, начиная с подпапки рабочей директории). То есть:

```{r}
netflix <- read.csv('data/netflix_titles.csv')
```

Почему так? Так как мы установили рабочую директорию (или запустили проект), то R по умолчанию теперь смотрит в папку нашего курса. А вот далее его надо сориентировать --- поэтому мы пишем `data/netflix_titles.csv`. То есть говорим ему: «иди дальше в папку `data` и принеси мне файл `netflix_titles.csv`. Собственно, он нам его и принёс.

Можно это проверить:
```{r}
head(netflix)
```

Что-то загрузилось. Это хорошо. Что именно --- выясним чуть позже.

Можно ли не прописывать `data`? Можно, но тогда придётся переложить файл данных в рабочую директорию (то есть папку курса). С одним файлом ничего, можно жить. А есть у вас 30 или 50 файлов разных респондентов? Уже тяжеловато и бардак. Поэтому, на мой взгляд, такая организация --- хороший компромисс: кода пишем чуть-чуть больше, но зато есть порядок[^1].

Конечно, можно хранить файлы данных где-то совсем отдельно. Но тогда и прописывать придётся путь от конревой папки компа:

```{r, eval=FALSE}
# например, можно прочитать файл прямо из папки «Загрузки»
netflix <- read.csv('/Users/antonangelgardt/Downloads/netflix_titles.csv')
```

Это выглядит не очень удобно.

На самом деле, в мире [облачных технологий](https://ru.wikipedia.org/wiki/Облачное_хранилище_данных) можно и вовсе обойтись без скачивания файлов на десктоп. Функция `read.csv()` вполне может прочитать файл прямо из интернета:

```{r, eval=FALSE}
# это ссылка на мой GitHub, где лежит нужный нам файл
netflix <- read.csv('https://raw.githubusercontent.com/angelgardt/hseuxlab-wlm2021/master/data/netflix_titles.csv')
```

Однако стоит помнить, что наши собранные руками данные в облаках, скорее всего, не лежат. Поэтому надо уметь загрузить файл и из интернета, и с компа.


### Форматы данных

Мы тактично соскользнули с момента расширения файла. Напомню, что у нас файл `netflix_titles.csv`. Пришло время уделить этому внимание.

Мы говорили о [типах данных](#datatypes), о [структурах данных](#datastructures) --- а теперь поговорим о *форматах данных*.

**Формат данных** --- это характеристика данных, которая определяет много чего:

* какие программы могут работать с этим файлом
* как структурирован файл внутри
* как структурированный файл разбирается на неструктирированные последовательности байтов (для хранения в памяти компьютера) и преобразуются обратно…

Ну, короче куча-куча всего. Формат файла (не вдаваясь в детали) задаётся его *разширением*, то есть тем, что написано после точки в его названии (`.R`, `.doc`, `.xlsx`, `.xml`, `.txt`, …).

Нас, прежде всего, интересуют файлы данных, поэтому об их форматах мы и поговорим.


#### Текстовые форматы

Проще всего хранить данные в тексте. Это удобно, такие файлы мало весят и в них можно поместить большое количество информации. Самый простой текстовый формат --- это `.txt`. Это тот самый «Блокнот», с которым наверняка когда-то все сталкивались. Никакого форматирования, никакой лишней мишуры --- только текст. Но нам ведь нужно из этого текста каким-то образом потом вытащить датафрейм. Для этого существуют *разделители.* Чаще всего в табличных `.txt` формате столбцы таблицы разделены между собой символами табуляции (`'\tab'`), а строки --- символом переноса строки (`'\n'`). Файл `.txt.` можно считать с помощью функции `read.table()`:


```{r}
df <- read.table('data/text_data.txt') # это данные про качесво красного вина
```
```{r}
# так как у вас нет отдельно скачанного этого датасета, то запустите вот эту команду, чтобы прочитать текстовый файл
# read.table() тоже умеет читать прямо из интернета
df <- read.table('https://raw.githubusercontent.com/angelgardt/hseuxlab-wlm2021/master/book/wlm2021-book/data/text_data.txt')
```

Если использовать другие разделители, например, запятую, то получится файл, содержащий *значения, разделённые запятыми* *(**c**omma **s**eparated **v**alues)*. Это и есть `.csv`-файлы, с которыми мы будем чаще всего работать.

> Несмотря на то, что по умолчанию операционная система пытается открыть CSV-шки в табличном редакторе (например, Excel), не надо на это вестись! CSV --- это текстовый формат данных.

По умолчанию, в CSV-файле столбцы разделяются запятыми, а строки --- символом переноса строки, поэтому функция `read.csv()` имеет соответствующие дефолтные настройки. Однако так бывает не всегда. Например, попробуем прочесть следующий файл:

```{r}
# снова про качество вина
wine <- read.csv('https://raw.githubusercontent.com/angelgardt/hseuxlab-wlm2021/master/book/wlm2021-book/data/winequality-red.csv')
```

Файл CSV-шный. Посмотрим, что получилось:

```{r}
head(wine) # команда выводит часть датасета в консоль
```

Что-то получилось. Но мы хотели увидеть нечто, напоминающее таблицу (вернее, датафрейм), а получилось явно что-то не то… Почему так? Потому что расширение `.csv` ещё не гарант того, что в файле в качестве разделителя использовалась запятая. Глобально --- это может быть вообще любой знак. В данном случае была использована точка с запятой. Если мы немного изменим команду и вручную укажем разделитель (*separator*), то всё будет ок:

```{r}
wine <- read.csv('https://raw.githubusercontent.com/angelgardt/hseuxlab-wlm2021/master/book/wlm2021-book/data/winequality-red.csv',
                 sep = ';')
head(wine)
```
Вот теперь хорошо.

<img class="taskimg" src="img/question.png">
<div class="task">
Как мы выяснили, запятая разделяет столбцы между собой в CSV-файлах. Но ведь запятая часто используется также и для отделения целой части от дробной в десятичных дробях. И здесь может произойти путаница.

Какой аргумент функции `read.csv()` отвечает за задание десятичного разделителя? И каково его дефолтное значение?
</div>


#### Табличные форматы

#### Форматы данных с особой разметкой

#### Файлы данных других статистических программ




## Исследование данных

Мы вдоволь наговорились о форматах данных. Теперь попробуем поработать с тем, что у нас есть. Напомню, что мы загрузили данные о фильмах и сериалах Netflix в переменную `netflix`.

Когда мы загрузили датасет, нам, прежде всего, хочется посмотреть, как оно выглядит. Это можно сделать несколькими способами. Если мы хотим более привычный для неискущённого пользователя вариант, то можно воспользоваться командой `View()` (именно с заглавной):

```{r, eval=FALSE}
View(netflix)
```

В соседней вкладке откроется датасет в привычном табличном виде, и можно будет посмотреть, корректно ли прочитались данные. Вариант удобный, но если у вас датасет в 1000 строк, «отсматривать глазами» косяки чтения данных совершенно бессмысленно.

Можно вывести первые несколько строк датасета в консоль --- это мы уже делали:

```{r}
head(netflix)
```

По умолчанию выводится шесть строк, однако этот парамент можно задать вручную:

```{r}
head(netflix, n = 4)
```

Аналогично можно вывести несколько последних строк:

```{r}
tail(netflix, n = 9)
```

Но мы помним, что датафрейм --- это список. А на списках работала функция `str()`, которая показывала структуру списка. Значит, можно выполнить эту функцию и на датафрейме? Да!

```{r}
str(netflix)
```

Тут даже попроще аутпут. Функция выводит структуру датафрейма, в которой отображены количество наблюдений (строк) и количество переменных (столбцов), сами переменные, в нём содержащиеся, их тип, а также первые несколько значений каждой переменной. Это позволяет составить общее представление о том, что есть в наших данных.

Есть ещё одна полезная функция, чтобы понять, всё ли ок с данными:

```{r}
summary(netflix)
```

Эта функция выводит «саммари» (неужели!) по каждой из переменных датасета. Если переменная числовая, то выводятся базовые описательные статистики (например, как в случае `release_year`). Наш же датасет оказался богат на строковые переменные, для которых `summary()` может посчитать только количество наблюдений и указать класс (тип) переменной.

Но не будем отчаиваться! И останавливаться тоже не будем. Для наших переменных будет полезно посмотреть таблицы частот:

```{r}
table(netflix$type)
```

Так, мы видим, что в наших данных есть фильмы и ТВ-шоу, и фильмов больше в два раза.

<img class="taskimg" src="img/code.png">
<div class="task">

В каком году было выпущено больше всего видеопродукции?

<input type="text" id="task1">
<input type="button" value="Проверить" onClick="check1()">
<div class="feedback" id="f1" hidden></div>

<script>
var input1 = document.getElementById("task1");
var f1 = document.getElementById("f1");

function check1() {
  if (input1.value == "2018") {
    f1.hidden = false;
    f1.innerHTML = 'Ответ корректен!';
    f1.style = "color:  #00aa4a";
  } else {
    f1.hidden = false;
    f1.innerHTML = 'Ответ некорректен…';
    f1.style = "color:  #b73239";
  }
}
</script>

```{r, include=FALSE}
table(netflix$release_year)
```

</div>

А ещё мы может построить таблицу частотности сразу по двум переменным:

```{r}
table(netflix$type, netflix$release_year)
```

Такие таблицы могут быть полезны, но конкретно в нашем случае уж слишком обширный период времени представлен в датасете --- получаются не слишком удобные таблицы частотности.

Сузим диапазон нашего поиска, ведь мы умеем индексировать датафреймы! Пусть нас интересует активность Netflix в период с 2010 по 2020 год. Нам нужно вытащить такой кусок датасета. Это значит, что нам нужны такие строки, которые содержат года, большие 2009 и меньшие 2021. Давайте пошагово:

```{r, eval=FALSE}
# поработаем с вектором годов
netflix$release_year > 2009 ## нашли те, что больше 2009
netflix$release_year < 2021 ## нашли те, что меньше 2021
netflix$release_year > 2009 & netflix$release_year < 2021 # соединили два логических условия

# индексируем получившимся вектором наш датасет
# выбираем нужные строки и все столбцы
netflix[netflix$release_year > 2009 & netflix$release_year < 2021, ]
```
```{r}
# запишем в новую переменную
netflix10 <- netflix[netflix$release_year > 2009 & netflix$release_year < 2021, ]
```

Как проверить, стало ли наблюдений меньше? Посмотреть количество строк:

```{r}
nrow(netflix)
nrow(netflix10)
```

Да, строк стало меньше. А столбцов?

```{r}
ncol(netflix)
ncol(netflix10)
```

А столбцов столько же, потому что мы отсабсетили все.

А правильно ли мы отсабсетили по годам? Это можно проверить, узнав уникальные значения переменной `release_year`:

```{r}
unique(netflix10$release_year)
sort(unique(netflix10$release_year)) # отсортируем для удобства
```
Да, сабсетнули верно!

<img class="taskimg" src="img/code.png">
<div class="task">

Какой из 10-х гг. был наиболее богат на фильмы?


```{r, include=FALSE}
table(netflix10$type, netflix10$release_year)
```

<input type="text" id="task2">
<input type="button" value="Проверить" onClick="check2()">
<div class="feedback" id="f2" hidden></div>

<script>
var input2 = document.getElementById("task2");
var f2 = document.getElementById("f2");

function check2() {
  if (input2.value == "2017") {
    f2.hidden = false;
    f2.innerHTML = 'Ответ корректен!';
    f2.style = "color:  #00aa4a";
  } else {
    f2.hidden = false;
    f2.innerHTML = 'Ответ некорректен…';
    f2.style = "color:  #b73239";
  }
}
</script>

</div>

Ещё одна полезная для разведочного анализа функция --- это `apply()`. Она применяет некоторую функцию по всем колонкам или столбцам нашего датафрейма. Наприме, мы хотим выяснить, если ли среди имеющихся переменных логические. Это можно сделать так:

```{r}
apply(netflix, 2, is.logical)
```

Первым аргументом мы указываем объект, который нас интересует. Далее указываем, по строкам (1) или по столбцам (2) мы будем выполнять нашу функцию. И третьим аргументом собственно определяем, какую функцию мы будем запускать --- в нашем случае `is.logical`.

> Да, мы передаём функцию в функцию --- это нормально. :)

Функция `is.logical()` проходится по столбцам нашего датафрейма, отрабатывает на каждом из них, а затем результаты собираются в именованный вектор. В итоге мы узнаём, что среди наших переменных логических нет.


<img class="taskimg" src="img/code.png">
<div class="task">

Сколько в нашем датасете строк, содержащих пропущенные значения?

*Подсказка: помните, что сравнение с `NA` возвращает `NA`.*


```{r, include=FALSE}
sum(apply(netflix, 1, function(x) sum(is.na(x))))
```

<input type="text" id="task3">
<input type="button" value="Проверить" onClick="check3()">
<div class="feedback" id="f3" hidden></div>

<script>
var input3 = document.getElementById("task3");
var f3 = document.getElementById("f3");

function check3() {
  if (input3.value == "0") {
    f3.hidden = false;
    f3.innerHTML = 'Ответ корректен!';
    f3.style = "color:  #00aa4a";
  } else {
    f3.hidden = false;
    f3.innerHTML = 'Ответ некорректен…';
    f3.style = "color:  #b73239";
  }
}
</script>

</div>



## `.RData`


[^1]: …и, возможно, закон, но это не точно…
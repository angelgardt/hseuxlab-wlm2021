# Структуры данных {#datastructures}

С тем, какие существуют данные, мы разобрались. Теперь надо понять, как мы их можем организовать.

## Векторы

Простейший способ организации данных --- это вектор. Казалось бы, мы знаем, что вектор --- это направленный отрезок. Безусловно, это так --- в рамках Евклидовой геометрии, которую мы в давнем прошлом учили. Однако это не единственный способ смотреть на вещи. С точки зрения структур данных, **вектор --- это одномерный массив**, а если по-русски, то **набор элементов одного типа (например, чисел)**.

Эти два представления, на самом деле, не противоречат друг другу. Геометрически, как мы сказали, вектор --- это направленный отрезок. Он задаётся через координаты начала и конца. Если мы условимся всегда начинать вектор из начала координат --- то есть будет считать равными все векторы, которые имеют одинаковую длину и одинаковое направление[^1] --- то мы сможем задавать вектор только через координаты его конца. В случае двумерного пространства вектор будет однозначно задаваться парой чисел $(x, y)$, в случае трёхмерного --- тройкой чисел $(x,y,z)$, а в случае $n$-мерного пространства --- набором чисел $(x_1, x_2, x_3, \dots, x_n)$.

Чтобы создать вектор в R надо воспользоваться функцией `c()`. Она принимает неограниченное количесво аргументов, которые объединяет в вектор. В вектор можно объединить элементы *только одного типа*.

```{r}
v <- c(1,2,3,5,6,7)
```

Сохраним получившийся числовой вектор в переменную `v`. Присваивание векторов ничем не отличается от присваивания чисел, во-первых, потому что *в R нет скаляров*, и все числа --- это векторы типа `numeric` длиной 1, а во-вторых, потому что и число, и вектор, и другие структуры данных (и даже функции!) --- всё это *объекты*. А assignment --- не что иное, как присваивание имени некоторому объекту, и нет разницы, что мы называем --- число, матрицу, список, датафрейм или функцию.


### Coercion [part two]
Взбунтуемся, и объеденим в один вектор разные типы данных:

```{r}
v0 <- c(1, 2, TRUE, FALSE)
v0
```

Бунт не удался --- вектор всё равно был создан. Но что произошло?

<center>
<img src="img/mem-coercion.jpg">
</center>

С приведением типов мы уже сталкивались, когда пытались складывать логические константы. Аналогично R действовал и здесь:

* есть задача создать вектор
* но на выход функции поступили данные различных типов
* придётся сделать так, чтобы тип был всё-таки один
* `numeric` к `logical` однозначно привести сложно (что есть `2` --- `TRUE` или `FALSE`?)
* `logical` к `numeric` приводится очень хорошо и красиво (`TRUE` --- `1`, `FALSE` --- `0`)
* после приведения типов можно выполнить команду создания вектора.

<img class="taskimg" src="img/code.png">
<div class="task">
А всё-таки: что есть `2`? `TRUE` или `FALSE`? Выясните, воспользовавшись функциями `isTRUE()` и `isFALSE()`.
</div>

<img class="taskimg" src="img/code.png">
<div class="task">
А будет ли работать (и как именно) ручное приведение `numeric` к `logical`? С помощью функции `as.logical()` приведите числа `0`, `1`, `2` и `-1` к логическому типу.
</div>


Сделаем вектор из полного салата --- добавим сторовые значения:

```{r}
v0 <- c(1, 2, TRUE, FALSE, 'text', 'string')
v0
```

Наблюдаем, что все свелось к типу `character`, что вполне ожидаемо, так как `2` в `"2"` превращается однозначно, а вот в какое число (или логическую константу) превратить `"string"`, не очень понятно.


<img class="taskimg" src="img/code.png">
<div class="task">
Как отработает следующая конструкция?

```{r, eval=FALSE}
v0 <- c(c(1, 2, TRUE), FALSE, 'text', 'string')
```

И почему именно так?
</div>

Собственно, можно вывести иерархию приведения типов:

<center>
<strong> logical < integer < numeric < complex < character </strong>
</center>


### Генерация числовых последовательностей

Создавать руками вектора --- это, конечно, радостно и приятно, но не очень юзабельно. На практике часто возникает потребность сгенерировать определенную числовую последовательность. Например, у вас есть опросниковые данные, из которых необходимо удалить персональные данные, но при этом сохранить возможность соотнести персональные данные и результаты анализа по каждому респонденту --- вам нужно сгенерировать переменную ID. Вам поможет оператор `:`, который генерирует последовательность в заданных пределах с шагом 1:

```{r}
1:10
15:0
```

Если вам нужна последовательно с другим шагом, например, 0.5, то подойдет функция `seq()`:

```{r}
seq(from = 1, to = 10, by = 0.5) # задаём шаг последовательности
seq(0, -6, -1.5) # или без указания названий аргументов
seq(from = 5, to = 30, length.out = 20) # задаём длину последовательности
```

Допустим, у вас есть данные (пусть выборка будет 15 человек), в которых каждые две строки относятся к одному респонденту, но к двум различным экспериментальным условиям (экспериментальному и контрольному). Тогда можно сделать такие переменные:

```{r}
rep(1:15, each = 2) # для id
rep(c('exp', 'control'), times = 15) # для обозначения условия
```

<img class="taskimg" src="img/code.png">
<div class="task">
Сгенерируйте последовательность от 106 до 124 с шагом 4, в которой каждый элемент будет повторяться подряд три раза.

```{r, echo=FALSE}
rep(seq(106, 124, 4), each = 3)
```
</div>

Также можно сгенерировать случайную последовательность чисел (например, для того, чтобы использовать её при сабсете случайной подвыборки данных):

```{r}
sample(x = 1:30, size = 15)
```

<img class="taskimg" src="img/question.png">
<div class="task">
По умолчанию функция `sample()` генерирует случайную последовательность с учетом того, что выпадение каждого числа равновероятно. Как изменить это условие?
</div>

<img class="taskimg" src="img/code.png">
<div class="task">
Сгенерируйте случайную последователность из 30 чисел от 1 до 10 при условии, что единица выпадает в два раза чаще, чем все остальные числа.

Чтобы результат получился такой же, как ниже, перед выполнением команды `sample(...)` выполните команду:

```{r}
set.seed(69)
```
```{r, echo=FALSE}
sample(1:10, 30, replace = TRUE, prob = c(2, rep(1, times = 9)))
```
</div>


### Операции с векторами

Операции, которые можно выполнять над векторами зависят от типа данных, которые содержатся в векторе. Чаще всего мы будем работать с числовыми векторами, поэтому разберем подробно именно их.

Пусть у нас будет два вектора:

```{r}
set.seed(42) # задаём положение для датчика случайных чисел
v1 <- sample(1:100, 20)
v2 <- sample(-50:100, 20)
```

Над векторами можно выполнять арифметические операции:

```{r}
v1 + v2
```
```{r}
v1 - v2
```
```{r}
v1 * v2
```
```{r}
v1 / v2
```

Они выполняются поэлементно, то есть соответсвующие элементы двух векторов складываются (вычитаются, умножаются, делятся), и в результате получается новый вектор.

Кроме того, векторы можно поэлементно сравнивать:

```{r}
v1 < v2
```
```{r}
v1 == v2
```
```{r}
v2 <= v1
```

Также к вектору можно применять и функции:

```{r}
sin(v1)
```

```{r}
log(v1)
```

```{r}
exp(v2)
```

Можно применять несколько функций подряд:
```{r}
log(abs(v2))
```

Большинство арифметических функций выполняется поэлементно, однако существуют такие, которые поэлементно не могут быть выполнены, например сумма по вектору:

```{r}
sum(v1)
```

Или функция, которая вычисляет длину вектора (в смысле количества элементов в нём):

```{r}
length(v2)
```


### Recycling

Доныне мы складывали векторы одинаковой длины. С ними всё ясно --- они складываются поэлементно. А что будет, если мы сложим векторы разной длины?

```{r}
v3 <- rep(1, times = 10); v3 # создаём векторы
v4 <- sample(1:100, 2); v4
v5 <- sample(1:100, 3); v5
```
```{r}
length(v3) # проверяем длину
length(v4)
length(v5)
```

Итак, сумма:
```{r}
v3 + v4
v3 + v5
```

Внимательно посмотрим на результат. В первом случае мы складывали вектор из десяти элементов и вектор из двух элементов. Чтобы выполнирь эту операцию R выполняет *зацикливание (recycling)* более короткого из двух, чтобы каждый элемент большего по длине вектора получил в соответствии элементн меньшего. Так как десять кратно двум, то по сути было выполнена следующая команда:

```{r}
v3 + rep(v4, 
         times = length(v3) / length(v4))
```

Во втором случае длина меньшего вектора не кратна длине большего, поэтому recycling происходит до тех пор, пока не будут покрыты все элемент большего вектора. Вектор из трех элементов укладывается на вектор из десяти элементов три раза --- поэтому мы видим в результате три раза последовательность `59, 11, 41` --- и остается ещё один десятый элемент, который суммируется в первым элементом меньшего вектора --- поэтому последний элемент в векторе результата `59`.


### Индексация векторов

В практике мы постоянно сталкиваемся в необходимость анализировать не все данные в векторе, а их часть. Поэтому встаёт вопрос о том, как эту часть извлечь?

Извлечение части данных из вектора называется **индексацией**. Это делается так:

```{r}
v1[1:10] # первые десять элементов вектора
v1[c(1,3,5,7)] # 1-й, 3-й, 5-й и 7-й элементы вектора
v1[sample(1:20, 5)] # случайная подвыборка пяти элементов
```

Логика проста --- чтобы взять часть вектора, нам нужен вектор индексов тех элементов, которые мы хотим вытащить. Его мы поместим в квадратные скобки --- и будет нам счастье. Вектор индектов можно получить любыми способами:

* сгенерировать последовательноть (как в первом варианте),
* задать индексы вручную, не забыв при этом обернуть их в фнукцию `c()`, чтобы указать, что это вектор, (как во втором варианте),
* воспользоваться функцией, которая возвращает вектор.

Полезно также является индексация через отрицательные индексы:

```{r}
v2
v2[-1] # все элементы, кроме первого
v2[-(1:5)] # все элементы, кроме первых пяти
```

```{r, include=FALSE}
write.csv(x = data.frame(x = sample(-300:1000, 500)),
           file = 'indexing_vectors.csv')
```

<img class="taskimg" src="img/code.png">
<div class="task">
Запишите в вектор результат следующей команды:
```{r, eval=FALSE}
read.csv('https://raw.githubusercontent.com/angelgardt/hseuxlab-wlm2021/master/book/wlm2021-book/data/indexing_vectors.csv')[['x']]
```
Задайте положение датчик случайный чисел:

```{r}
set.seed(123)
```

Выберите из получившего вектора все значения, *кроме тех*, которые попадут в случайную подвыборку из 50 наблюдений. Вычислите сумму элементов получившегося вектора.

```{r, include=FALSE}
ind <- read.csv('https://raw.githubusercontent.com/angelgardt/hseuxlab-wlm2021/master/book/wlm2021-book/data/indexing_vectors.csv')[['x']]
sum(ind[-sample(1:length(ind), 50)])
```

*Подсказка. Функции `sample()` необходимы границы интервала, из которого она генерирует случайную подвыборку. Одна из границ интервала --- длина вектора, с которым вы работаете.*

<div class="autocheck">
<input class="taskinput" id="input1" type="text">
<input class="taskcheck" type="button" value="Проверить" onClick="check1()">
<div class="taskans" id="taskans1" hidden></div>
</div>

</div>

```{js, echo=FALSE}
var input1 = document.getElementById("input1")
var taskans1 = document.getElementById("taskans1")

function check1() {
  if (input1.value == '149885') {
    taskans1.hidden = false;
    taskans1.innerHTML = 'Верно!';
    taskans1.style = "color:  #00aa4a";
  } else
  {
    taskans1.hidden = false;
    taskans1.innerHTML = 'У меня другой ответ…';
    taskans1.style = "color:  #b73239";
  }
}
```


Особого внимания заслуживает **индексация логическими векторами**. Например, мы хотим отобрать все элементы вектора, которые больше некоторого числа. Как это сделать?

Нам нужен вектор, которым мы будем индексировать исходный вектор. Как его получить? Известно, что при сравнении векторов между собой получается логический вектор. Но ведь число --- это тоже вектор, просто единичной длины? Значит, если мы будем сравнивать вектор с числом, произойдёт recycling, в результате которого каждый элемент вектора будет сравнен с этим числом. То есть:

```{r}
v1 > 40
```

Отлично! Вектор есть. Можно ли им проидексировать наш исходный вектор `v1`? Можно! Аналогично тому, как мы это уже делали.

```{r}
v1[v1 > 40]
```

Конструкция, возможно, выглядит немного странновато --- но работает!

<img class="taskimg" src="img/code.png">
<div class="task">
Возмите вектор `v1`, с которым мы только что работали и с опорой на имеющийся в предыдущем чанке код, вытащите из вектора элементы, который *не больше* среднего значения по вектору.

Мы ещё не изучали описательные статистики, но со средним арифметическим вроде все знакомы? Вычисляется оно с помощью функции `mean()`.

```{r, echo=FALSE}
v1[v1 <= mean(v1)]
```

</div>


### NA, NaN, NULL

Взбунтуемся ещё раз и посмотрим, что получится, если мы будем вытаскивать из вектора элементы, используя индексы, которые выходят за границы длины вектора. Например, у нас есть вектор `v2`, длина которого

```{r}
length(v2)
```

Попробуем сделать так:

```{r}
v2[15:25]
```

Мы получили нечто, с чем ранее не сталкивались. `NA` (от *not available*) обозначает значение, которое недоступно. Как правило, в реальных данных они появляются при каких-либо ошибках записи данных. Впрочем, не всегда. Можно придумать и такой дизайн исследования, когда пропуски также будут информативны и могут анализировться. В нашем случае мы обратились к элементам, которых нет в нашем векторе, поэтому R ничего более не смог сделать, как вернуть нам свидетельство того, что такие элементы он из вектора достать не смог.

<img class="taskimg" src="img/question.png">
<div class="task">
К какому типу даных относится константа `NA`?
</div>

`NA` ведёт себя весьма специфично. Например, если мы попробуем посчитать сумму по получившемуся вектору, то результат будет следующим:

```{r}
sum(v2[15:25])
```

Аналогичная ситуация возникнет, если мы будем вычислять среднее:

```{r}
mean(v2[15:25])
```

Такое поведение функций может поначалу напрягать, однако оказывается очень полезным при работе с реальными данными.


<img class="taskimg" src="img/question.png">
<div class="task">
И всё же функция `sum()` не так проста, и умеет бороться с `NA`. Как нужно изменить команду, чтобы сумма была посчитана?
</div>


Попробуем вычислить логарифм по вектору `v2`:

```{r}
log(v2)
```

Опять всё не слава богу. Теперь у нас `NaN`. Это почти как `NA`, но не совсем. `NaN` обозначает не-число (*not a number*). То есть, это не пропущенное значение, оно существует, но R его не может вычислить. Если мы сравним два вектора,

```{r}
v2; log(v2)
```

то обнаружим, что `NaN` появляется там, где мы пытаемся вычислить логарим отрицательного числа. А, как мы помним, функция логарифма определена только на положительно полуоси $x$. Вот и получается, что логарифм отрицательного аргумента --- это какая-то неведомая сущность, то точно не-число.

В функциях `NaN` ведёт себя аналогично `NA`:

```{r}
sum(log(v2))
```

<img class="taskimg" src="img/question.png">
<div class="task">
К какому типу даных относится константа `NaN`?
</div>

Мы поговорили о двух важный константах используемых в R. Есть ещё одна, и имя её `NULL`. Это имя обозначает «ничего», то есть, что объект пуст.

Например, возьмем вектор `v`, который мы создавали в самом начале, и положим в него `NULL`:

```{r}
v <- NULL
v
```

Теперь в этом векторе ничего не лежит.

`NULL` может использоваться при задании аргументов функций или как результат работы функций, если возвращается пустой объект.



## Матрицы

Говоря о векторах, мы обозначили, что вектор --- это одномерный массив. А раз есть одномерные массивы, значит бывают какие-то ещё? Да. Сгенерируем некоторый вектор:

```{r}
v6 <- sample(1:100, 12); v6
```

и попробуем его «сложить» в «таблицу» так, чтобы в каждой строке было по три числа:

```{r}
m1 <- matrix(v6, ncol = 3); m1
```

Так как мы «складываем друг на друга» части одномерного массива, у нашего нового массива возникает новое измерение --- если вектор был только одной строкой[^2], то теперь в нашем массиве есть и строки, и столбцы. **Двумерный массив назвается матрицей**.

```{r}
class(m1)
```

И поэтому для его создания мы использовали функцию `matrix()`. В качестве основных аргументов она хочет видеть вектор, который мы будет «упаковывать» в матрицу, а также количество строк или столбцов новой матрицы.


### Индексация матриц

От того, что мы свернули вектор в матрицу, он не перестал быть вектором. [Шок!] То есть матрица по сути всё ещё тот же самый вектор, поэтому индексировать её можно точно так же, как и вектор:

```{r}
v6[1]; m1[1]
v6[4]; m1[4]
v6[11]; m1[11]
```

Однако поскольку матрица --- это всё же матрица, она отличается от вектора тем, что у неё есть дополнительный атрибут `dim`, который отображает её размерность:

```{r}
dim(m1)
```

В данном случае наблюдаем, что размерность матрицы $4 × 3$, и это справедливо, ведь именно такую матрицу мы и создавали. А раз у нас имеется указание на количество строк и столбцов в матрице, то мы можем вытащить элемент(ы) как раз по его позиции:

```{r}
m1[1, 2] # вытаскиваем элемент из первой строки и второго столбца
```

Те же квадратные скобки, только указываем мы теперь две «координаты» --- сначала строки, затем столбцы. Как не запутаться? Аналогия с координатами не случайна: строки --- горизонтальны, первая координата на координата на координатной плоскости ($x$) тоже задаёт положение точки на горизонтальной оси; столбцы --- вертикальны, вторая координата ($y$) задает положение точки на вертикальной оси.

<img class="taskimg" src="img/question.png">
<div class="task">
Какой результат вернет команда `dim(v6)`? Почему именно такой?
</div>

Также мы можем вытащить не только отдельный элемент, но и какую-то часть матрицы. Всё работает аналогично векторам:

```{r}
m1[1:3, 2:3]
```

Если мы выползем за границы индексации, R начнёт ругаться:
```{r, error=TRUE}
m1[1:3, 2:4]
```

<img class="taskimg" src="img/question.png">
<div class="task">
На практике нам часто надо вытащить отдельный столбец (или несколько столбцов), содержащих все строки. Как это можно сделать в R?

А если нам нужны несколько строк, содержащих все столбцы?
</div>


### Операции в матрицами

[Как вы знаете](#matrix), с матрицами можно делать много всякого разного.

```{r}
# наделаем матриц для развлечения
m2 <- matrix(sample(1:100, 12), nrow = 4); m2
m3 <- matrix(sample(1:100, 12), ncol = 2); m3
m4 <- matrix(sample(1:100, 9), nrow = 3); m4
m5 <- matrix(sample(1:100, 9), nrow = 3); m5
```

Матрицы можно складывать[^3] (поэлементно):

```{r}
m1 + m2
```

Но только те, которые имеют одинаковый размер:

```{r, error=TRUE}
m1 + m4
```

Матрицы можно умножать[^4] (поэлементно):

```{r}
m1 * m2
```

Но только те, которые имеют одинаковый размер:

```{r, error=TRUE}
m1 * m4
```

<img class="taskimg" src="img/question.png">
<div class="task">
Что будет, если мы попробуем умножить матрицу на число?

*Напоминание: матрица --- это вектор.*
</div>

<img class="taskimg" src="img/question.png">
<div class="task">
Что будет, если мы попробуем посчитать сумму по матрице?

*Напоминание: матрица --- это всё ещё вектор.*
</div>

Но матрицы можно перемножать ещё и матрично. Тогда требуется соответствие вутренних размерностей матриц:

```{r, error=TRUE}
dim(m1); dim(m2)
m1 %*% m2
```

```{r}
dim(m1); dim(m4)
m1 %*% m4
```

Помним, что матричное умножение *некуммутативно*:

```{r}
m4 %*% m5
m5 %*% m4
```

Можно вычислить [детерминант](#det) матрицы:

```{r}
det(m4)
```

И найти [обратную матрицу](#inv):
```{r}
solve(m4)
```

А таке вычислить [след матрицы](#trace):
```{r}
sum(diag(m4)) # специальной функции не придумали
```


## Списки

До текущего момента мы говорили о структурах данных, которые требуют одинакового типа данных в себе. Давайте теперь вообразим вектор без ограничения на однотипность данных. Это будет **список (list)**.

```{r}
l <- list(69, "text", TRUE)
l
```

Но список даёт нам ещё больше возможностей, потому что он может собирать в себя вообще любые объекты:

```{r}
l2 <- list(c("This", "list", "contains", "a", "matrix"), m1, l)
l2
```

Таким образом, список может являть собой крайне сложную структуру. Чтобы разобраться, как устроен конкретный список, можно воспользоваться функцией `str()`, которая отобразит структуру списка:

```{r}
str(l2)
```

Как видно в аутпуте функции, список содержит три элемента: текстовый вектор длиной 5, массив целых чисел, размером 4×3, и список, который в свою очерель состоит также из трёх элементов --- числа 69, строкового вектора, содержащего одно значение ("text") и логического вектора длиной 1, который содержит значение «истина».

Можно назвать отдельные элементы списка собственными именами:

```{r}
# создадим список такой же, как l2, только именованный
l3 <- list(description = c("This", "list", "contains", "a", "matrix"),
           matrix = m1,
           inner_list = l)
l3
```

<img class="taskimg" src="img/code.png">
<div class="task">
В R можно создать и именованный вектор, если действовать аналогично созданию именованного списка.

Создайте вектор, который будет содержать пять элементов: ваше имя (name), вашу фамилию (surname), вашу дату рождения (birthdate), название вашей любимой книги (book) и ваш любимый цвет (color).

```{r, echo=FALSE}
vnamed <- c(name = 'Anton',
            surname = 'Angelgardt',
            birthdate = '21.04.1997',
            book = "A. Camus. L'étranger",
            color = 'black')
vnamed
```
</div>


### Индексация списков

Списки в R появляются достаточно часто --- и, главным образом, как результат работы функций. Собственными руками мы их создавать вряд ли когда либо будем, а вот вытаскивать из них инфу по частям нам научиться надо обязательно.

Поскольку список как и вектор состоит из отдельных элементов, которые в нём расположены в определённом порядке, то можно поступить со списком как с вектором:

```{r}
l3[1]
```

Мы помним, что с списке `l3` первым элементом был строковый вектор. Однако когда мы обратились к первому элементу, нам вернулся список, содержащий этот вектор. Да, такова особенность индексации списков --- если мы используем одинарные квадратные скобки, то возвращается список из одного элемента. Почему так? Потому что если мы заходим вытащить, например, первые два элемента, то они могут оказаться различной структуры, и вернуть их вместе, кроме как списком, нет варианта.

```{r}
l3[1:2]
```

Чтобы вытащить сам вектор, нам потребуются двойные квадратные скобки:

```{r}
l3[[1]]
```

Можно пойти далее и вытащить какой-то элемент из вектора прямо в этой же строке:

```{r}
l3[[1]][c(1, 5)] # вытащим сразу первый и пятый
```

Раз у нас именованный список, то можно вытащить элемент по имени (с векторами тоже работает):

```{r}
l3['matrix'] # так вернётся список
l3[['matrix']] # а так сама матрица
```

<img class="taskimg" src="img/code.png">
<div class="task">
Из созданного в предыдущем задании вектора вытащите по имени элементы `name`, `surname`, `birthdate`.

```{r, echo=FALSE}
vnamed[c('name', 'surname', 'birthdate')]
```
</div>

Но списки нам предоставляют ещё одну удобную и полезную фичу --- индексацию по имени, но другим способом:

```{r}
l3$description
l3$matrix
```

Обратите внимание, что в таком случае сразу возвращается «голый» объект --- вектор, матрица, etc. Запомните этот способ --- так мы будем делать о-о-очень часто (примерно всегда).

<img class="taskimg" src="img/code.png">
<div class="task">

```{r, include=FALSE, eval=FALSE}
hugelist <- list(
  book1 = list(
    main = list(
      title = c('Machine', 'Learning', 'and', 'Artificial', 'Intelligence'),
      authors = c('Ameet V Joshi')
      ),
    copyright_info = list(
      copyright = 2020,
      publisher = 'Springer International Publishing',
      copyright_holder = 'Springer Nature Switzerland AG'
      ),
    identifiers = list(
      DOI = '10.1007/978-3-030-26622-6',
      ISBN = c(
        eBook = '978-3-030-26622-6',
        Hardcover = '978-3-030-26621-9',
        Softcover = '978-3-030-26624-0'
      )
    )
  ),
  book2 = list(
    main = list(
      title = c('Digital', 'Transformation', 'of', 'the', 'Design', 'Construction', 'and', 'Management', 'Processes', 'of', 'the', 'Built', 'Environment'),
      authors = c('Bruno Daniotti', 'Marco Gianinetto', 'Stefano Della Torre')
      ),
    copyright_info = list(
      copyright = 2020,
      publisher = 'Springer International Publishing',
      copyright_holder = 'The Editor(s) (if applicable) and The Author(s)'
      ),
    identifiers = list(
      DOI = '10.1007/978-3-030-33570-0',
      ISBN = c(
        eBook = '978-3-030-33570-0',
        Hardcover = '978-3-030-33569-4',
        Softcover = '978-3-030-33572-4'
      )
    )
  ),
  book3 = list(
    main = list(
      title = c('Probabilistic', 'Graphical', 'Models'),
      authors = c('Luis Enrique Sucar')
      ),
    copyright_info = list(
      copyright = 2021,
      publisher = 'Springer International Publishing',
      copyright_holder = 'Springer Nature Switzerland AG'
      ),
    identifiers = list(
      DOI = '10.1007/978-3-030-61943-5',
      ISBN = c(
        eBook = '978-3-030-61943-5',
        Hardcover = '978-3-030-61942-8',
        Softcover = NA
      )
    )
  ),
  book4 = list(
    main = list(
      title = c('Computational', 'Methods', 'for', 'Deep', 'Learning'),
      subtitle = c('Theoretic, Practice and Applications'),
      authors = c('Wei Qi Yan')
      ),
    copyright_info = list(
      copyright = 2021,
      publisher = 'Springer International Publishing',
      copyright_holder = 'The Editor(s) (if applicable) and The Author(s), under exclusive license to Springer Nature Switzerland AG'
      ),
    identifiers = list(
      DOI = '10.1007/978-3-030-61081-4',
      ISBN = c(
        eBook = '978-3-030-61081-4',
        Hardcover = '978-3-030-61080-7',
        Softcover = NA
      )
    )
  ),
  book5 = list(
    main = list(
      title = c('The', 'Art', 'of', 'War', 'for', 'Computer', 'Security'),
      authors = c('Tom Madsen')
      ),
    copyright_info = list(
      copyright = 2019,
      publisher = 'Springer International Publishing',
      copyright_holder = 'Springer Nature Switzerland AG'
      ),
    identifiers = list(
      DOI = '10.1007/978-3-030-28569-2',
      ISBN = c(
        eBook = '978-3-030-28569-2',
        Hardcover = '978-3-030-28568-5',
        Softcover = '978-3-030-28571-5'
      )
    )
  )
)
str(hugelist)
save.image('list.RData')
```

Скачайте [по ссылке](https://github.com/angelgardt/hseuxlab-wlm2021/blob/master/book/wlm2021-book/list.RData?raw=true) файл `list.RData`. Поместите его в текущую рабочую директорию. Затем выполните команду ниже:

```{r, eval=FALSE}
load('list.RData')
```

В окне Environment появиться объект типа «список», который содержит библиографическую информацию о нескольких книгах. Изучите этот объект и ответьте на вопросы ниже с применением навыков индексации списков.


1. Сколько слов содержится в названии первой книги?

<div class="autocheck">
<input class="taskinput" id="input2" type="text">
<input class="taskcheck" type="button" value="Проверить" onClick="check2()">
<div class="taskans" id="taskans2" hidden></div>
</div>

2. Кто автор самой старой из представленных книг?

<div class="autocheck">
<input class="taskinput" id="input3" type="text">
<input class="taskcheck" type="button" value="Проверить" onClick="check3()">
<div class="taskans" id="taskans3" hidden></div>
</div>

3. У какой (каких) книг отсутствует Softcover ISBN? *В ответ введите одно число или несколько чисел через пробел.*

<div class="autocheck">
<input class="taskinput" id="input4" type="text">
<input class="taskcheck" type="button" value="Проверить" onClick="check4()">
<div class="taskans" id="taskans4" hidden></div>
</div>


</div>

```{js, echo=FALSE}
var input2 = document.getElementById("input2")
var taskans2 = document.getElementById("taskans2")
var input3 = document.getElementById("input3")
var taskans3 = document.getElementById("taskans3")
var input4 = document.getElementById("input4")
var taskans4 = document.getElementById("taskans4")

function check2() {
  if (input2.value == '5') {
    taskans2.hidden = false;
    taskans2.innerHTML = 'Верно!';
    taskans2.style = "color:  #00aa4a";
  } else
  {
    taskans2.hidden = false;
    taskans2.innerHTML = 'У меня другой ответ…';
    taskans2.style = "color:  #b73239";
  }
}

function check3() {
  if (input3.value.toLowerCase() == 'tom madsen') {
    taskans3.hidden = false;
    taskans3.innerHTML = 'Верно!';
    taskans3.style = "color:  #00aa4a";
  } else
  {
    taskans3.hidden = false;
    taskans3.innerHTML = 'У меня другой ответ…';
    taskans3.style = "color:  #b73239";
  }
}

function check4() {
  if (input4.value == '3 4') {
    taskans4.hidden = false;
    taskans4.innerHTML = 'Верно!';
    taskans4.style = "color:  #00aa4a";
  } else
  {
    taskans4.hidden = false;
    taskans4.innerHTML = 'У меня другой ответ…';
    taskans4.style = "color:  #b73239";
  }
}

```


## Датафреймы

> Ура! Мы добрались до самого интересноо в самого важного!

Кратко вспомним, что мы умеем к этому моменту:

* манипулировать с векторами (создавать, индексировать, производить разные математические операции)
* работать с матрицами (создавать, индексировать, производить разные математические операции)
* обращаться со списками (создавать и индексировать различными способами)

Так вот все эти знания и умения нам нужны, чтобы мастерски жонглировать датафреймами. **Датафрейм** --- это детище большой любви матрицы и списка:

В одном из домашних заданий вы создавали матрицу, которая содержала имена респондентов, их пол, город проживания и любимый цвет. Но ождиаемое ограничение было в том, что все данные неизбежно приводились к строковому типу. И в таком варианте вроде бы ничего криминального, но если мы захотим добавить данные о возраста --- что делать? Хорошо мы, чтобы они сохранились в числовом формате, ведь так с ними дальше будет удобно работать.

```{r}
# немного изменим набор переменных для демонстрации возможностей
df <- data.frame(name = c('Иван', 'Алёна', 'Сергей', 'Елена', 'Кристина'),
                 age = c(23, 34, 52, 19, 26),
                 sex = c('муж', 'жен', 'муж', 'жен', 'жен'),
                 city = c("Mосква", "Тверь", "Тверь", "Питер", "Москва"))
df
```

Обратите внимание, датафрейм создается практически так же, как и список, только функция другая. А в итоге получается привычная нам таблица! Magique!

Как устроена эта таблица? По сути датафрейм --- это *именованный список*, каждый элемент которого --- это *вектор* определённой длины (одинаковой для всех векторов, входящих в этот список). Так они одинаковой длины, то их можно «поставить рядом друг с другом» как колонки матрицы. Собственно, так и получается. Вот только в данному случае разные столбцы могут содержать разный тип данных.

И тем не менее, поскольку датафрейм наследует свойства обоих своих «родителей», обращаться с ним можно и как со списком, и как с матрицей:

```{r}
str(df) # изучаем структуру
df$name # вытаскиваем элемент списка (вектор имён респондентов)
df$name[1:3] # индексируем вектор имён респондентов
df[, 1] # так тоже срабоает
df[1] # и даже так, но какая структура данных вернулась?
df[1:2, 3:4] # ну это просто пушка
```

Можно добавить новые переменные:

```{r}
df$married <- FALSE # recycling has happened
```


<img class="taskimg" src="img/code.png">
<div class="task">
Как вы поняли, возможностей индексации датафрейма --- много. Но мы обозначили не все!

Вытащите из имеющегося датафрейма `df` строки переменной `city` со второй по пятую, не используя команды, обозначенные выше.

*Подсказка: как можно ещё индексировать список?*

```{r, echo=FALSE}
df[2:5, 'city']
```
</div>

<img class="taskimg" src="img/code.png">
<div class="task">
Парой строк выше мы создавали новую переменную в датафрейме с помощью присваивания. Но давайте разнообразим наши данные. Используйте индексацию и оператор присваивания, чтобы привести датафрейм к следующему виду:

```{r, echo=FALSE}
df$married[c(2:3, 5)] <- TRUE
df
```
</div>

Когда мы говорили об индексации векторов, мы затрагивали тему индексации логическими векторами. Ничего не мешает нам воплотить эту идею и с датафреймами:

```{r}
df$sex[df$age > mean(df$age)]
```

Или вот так, например:

```{r}
df[df$age > mean(df$age), 'sex']
```

<img class="taskimg" src="img/code.png">
<div class="task">
Мы вытащили по логическому условию значения определенной переменной датафрейма. А как вытащить часть датафрейма по некоторому условию? То есть необходимо оставить все колонки, но строки отобрать по определённому условию.

Создайте подвыборку наших респондентов, возраст которых меньше среднего по всей имеющейся выборке.

```{r, echo=FALSE}
df[df$age < mean(df$age), ]
```
</div>

Ну, пожалуй, и хватит топтаться в основах --- пора уже чем-то серьёзным заняться!


[^1]: Такие векторы называются *свободными*.
[^2]: Или столбцом, что в данном случае не важно.
[^3]: А если можно складывать, соответственно, можно и вычитать.
[^4]: А если можно умножать, соответственно, можно и делить.

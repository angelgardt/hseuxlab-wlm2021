# Структуры данных

С тем, какие существуют данные, мы разобрались. Теперь надо понять, как мы их можем организовать.

## Векторы

Простейший способ организации данных --- это вектор. Казалось бы, мы знаем, что вектор --- это направленный отрезок. Безусловно, это так --- в рамках Евклидовой геометрии, которую мы в давнем прошлом учили. Однако это не единственный способ смотреть на вещи. С точки зрения структур данных, **вектор --- это одномерный массив**, а если по-русски, то **набор элементов одного типа (например, чисел)**.

Эти два представления, на самом деле, не противоречат друг другу. Геометрически, как мы сказали, вектор --- это направленный отрезок. Он задаётся через координаты начала и конца. Если мы условимся всегда начинать вектор из начала координат --- то есть будет считать равными все векторы, которые имеют одинаковую длину и одинаковое направление[^1] --- то мы сможем задавать вектор только через координаты его конца. В случае двумерного пространства вектор будет однозначно задаваться парой чисел $(x, y)$, в случае трёхмерного --- тройкой чисел $(x,y,z)$, а в случае $n$-мерного пространства --- набором чисел $(x_1, x_2, x_3, \dots, x_n)$.

Чтобы создать вектор в R надо воспользоваться функцией `c()`. Она принимает неограниченное количесво аргументов, которые объединяет в вектор. В вектор можно объединить элементы *только одного типа*.

```{r}
v <- c(1,2,3,5,6,7)
```

Сохраним получившийся числовой вектор в переменную `v`. Присваивание векторов ничем не отличается от присваивания чисел, во-первых, потому что *в R нет скаляров*, и все числа --- это векторы типа `numeric` длиной 1, а во-вторых, потому что и число, и вектор, и другие структуры данных (и даже функции!) --- всё это *объекты*. А assignment --- не что иное, как присваивание имени некоторому объекту, и нет разницы, что мы называем --- число, матрицу, список, датафрейм или функцию.


### Coercion [part two]
Взбунтуемся, и объеденим в один вектор разные типы данных:

```{r}
v0 <- c(1, 2, TRUE, FALSE)
v0
```

Бунт не удался --- вектор всё равно был создан. Но что произошло?

<center>
<img src="img/mem-coercion.jpg">
</center>

С приведением типов мы уже сталкивались, когда пытались складывать логические константы. Аналогично R действовал и здесь:

* есть задача создать вектор
* но на выход функции поступили данные различных типов
* придётся сделать так, чтобы тип был всё-таки один
* `numeric` к `logical` однозначно привести сложно (что есть `2` --- `TRUE` или `FALSE`?)
* `logical` к `numeric` приводится очень хорошо и красиво (`TRUE` --- `1`, `FALSE` --- `0`)
* после приведения типов можно выполнить команду создания вектора.

<img class="taskimg" src="img/code.png">
<div class="task">
А всё-таки: что есть `2`? `TRUE` или `FALSE`? Выясните, воспользовавшись функциями `isTRUE()` и `isFALSE()`.
</div>

<img class="taskimg" src="img/code.png">
<div class="task">
А будет ли работать (и как именно) ручное приведение `numeric` к `logical`? С помощью функции `as.logical()` приведите числа `0`, `1`, `2` и `-1` к логическому типу.
</div>


Сделаем вектор из полного салата --- добавим сторовые значения:

```{r}
v0 <- c(1, 2, TRUE, FALSE, 'text', 'string')
v0
```

Наблюдаем, что все свелось к типу `character`, что вполне ожидаемо, так как `2` в `"2"` превращается однозначно, а вот в какое число (или логическую константу) превратить `"string"`, не очень понятно.


<img class="taskimg" src="img/code.png">
<div class="task">
Как отработает следующая конструкция?

```{r, eval=FALSE}
v0 <- c(c(1, 2, TRUE), FALSE, 'text', 'string')
```

И почему именно так?
</div>

Собственно, можно вывести иерархию приведения типов:

<center>
<strong> logical < integer < numeric < complex < character </strong>
</center>


### Генерация числовых последовательностей

Создавать руками вектора --- это, конечно, радостно и приятно, но не очень юзабельно. На практике часто возникает потребность сгенерировать определенную числовую последовательность. Например, у вас есть опросниковые данные, из которых необходимо удалить персональные данные, но при этом сохранить возможность соотнести персональные данные и результаты анализа по каждому респонденту --- вам нужно сгенерировать переменную ID. Вам поможет оператор `:`, который генерирует последовательность в заданных пределах с шагом 1:

```{r}
1:10
15:0
```

Если вам нужна последовательно с другим шагом, например, 0.5, то подойдет функция `seq()`:

```{r}
seq(from = 1, to = 10, by = 0.5) # задаём шаг последовательности
seq(0, -6, -1.5) # или без указания названий аргументов
seq(from = 5, to = 30, length.out = 20) # задаём длину последовательности
```

Допустим, у вас есть данные (пусть выборка будет 15 человек), в которых каждые две строки относятся к одному респонденту, но к двум различным экспериментальным условиям (экспериментальному и контрольному). Тогда можно сделать такие переменные:

```{r}
rep(1:15, each = 2) # для id
rep(c('exp', 'control'), times = 15) # для обозначения условия
```

<img class="taskimg" src="img/code.png">
<div class="task">
Сгенерируйте последовательность от 106 до 124 с шагом 4, в которой каждый элемент будет повторяться подряд три раза.

```{r, echo=FALSE}
rep(seq(106, 124, 4), each = 3)
```
</div>

Также можно сгенерировать случайную последовательность чисел (например, для того, чтобы использовать её при сабсете случайной подвыборки данных):

```{r}
sample(x = 1:30, size = 15)
```

<img class="taskimg" src="img/question.png">
<div class="task">
По умолчанию функция `sample()` генерирует случайную последовательность с учетом того, что выпадение каждого числа равновероятно. Как изменить это условие?
</div>

<img class="taskimg" src="img/code.png">
<div class="task">
Сгенерируйте случайную последователность из 30 чисел от 1 до 10 при условии, что единица выпадает в два раза чаще, чем все остальные числа.

Чтобы результат получился такой же, как ниже, перед выполнением команды `sample(...)` выполните команду:

```{r}
set.seed(69)
```
```{r, echo=FALSE}
sample(1:10, 30, replace = TRUE, prob = c(2, rep(1, times = 9)))
```
</div>


### Операции с векторами

Операции, которые можно выполнять над векторами зависят от типа данных, которые содержатся в векторе. Чаще всего мы будем работать с числовыми векторами, поэтому разберем подробно именно их.

Пусть у нас будет два вектора:

```{r}
set.seed(42) # задаём положение для датчика случайных чисел
v1 <- sample(1:100, 20)
v2 <- sample(-50:100, 20)
```

Над векторами можно выполнять арифметические операции:

```{r}
v1 + v2
```
```{r}
v1 - v2
```
```{r}
v1 * v2
```
```{r}
v1 / v2
```

Они выполняются поэлементно, то есть соответсвующие элементы двух векторов складываются (вычитаются, умножаются, делятся), и в результате получается новый вектор.

Кроме того, векторы можно поэлементно сравнивать:

```{r}
v1 < v2
```
```{r}
v1 == v2
```
```{r}
v2 <= v1
```

Также к вектору можно применять и функции:

```{r}
sin(v1)
```

```{r}
log(v1)
```

```{r}
exp(v2)
```

Можно применять несколько функций подряд:
```{r}
log(abs(v2))
```

Большинство арифметических функций выполняется поэлементно, однако существуют такие, которые поэлементно не могут быть выполнены, например сумма по вектору:

```{r}
sum(v1)
```

Или функция, которая вычисляет длину вектора (в смысле количества элементов в нём):

```{r}
length(v2)
```


### Recycling

Доныне мы складывали векторы одинаковой длины. С ними всё ясно --- они складываются поэлементно. А что будет, если мы сложим векторы разной длины?

```{r}
v3 <- rep(1, times = 10); v3 # создаём векторы
v4 <- sample(1:100, 2); v4
v5 <- sample(1:100, 3); v5
```
```{r}
length(v3) # проверяем длину
length(v4)
length(v5)
```

Итак, сумма:
```{r}
v3 + v4
v3 + v5
```

Внимательно посмотрим на результат. В первом случае мы складывали вектор из десяти элементов и вектор из двух элементов. Чтобы выполнирь эту операцию R выполняет *зацикливание (recycling)* более короткого из двух, чтобы каждый элемент большего по длине вектора получил в соответствии элементн меньшего. Так как десять кратно двум, то по сути было выполнена следующая команда:

```{r}
v3 + rep(v4, 
         times = length(v3) / length(v4))
```

Во втором случае длина меньшего вектора не кратна длине большего, поэтому recycling происходит до тех пор, пока не будут покрыты все элемент большего вектора. Вектор из трех элементов укладывается на вектор из десяти элементов три раза --- поэтому мы видим в результате три раза последовательность `59, 11, 41` --- и остается ещё один десятый элемент, который суммируется в первым элементом меньшего вектора --- поэтому последний элемент в векторе результата `59`.


### Индексация векторов

В практике мы постоянно сталкиваемся в необходимость анализировать не все данные в векторе, а их часть. Поэтому встаёт вопрос о том, как эту часть извлечь?

Извлечение части данных из вектора называется **индексацией**. Это делается так:

```{r}
v1[1:10] # первые десять элементов вектора
v1[c(1,3,5,7)] # 1-й, 3-й, 5-й и 7-й элементы вектора
v1[sample(1:20, 5)] # случайная подвыборка пяти элементов
```

Логика проста --- чтобы взять часть вектора, нам нужен вектор индексов тех элементов, которые мы хотим вытащить. Его мы поместим в квадратные скобки --- и будет нам счастье. Вектор индектов можно получить любыми способами:

* сгенерировать последовательноть (как в первом варианте),
* задать индексы вручную, не забыв при этом обернуть их в фнукцию `c()`, чтобы указать, что это вектор, (как во втором варианте),
* воспользоваться функцией, которая возвращает вектор.

Полезно также является индексация через отрицательные индексы:

```{r}
v2
v2[-1] # все элементы, кроме первого
v2[-(1:5)] # все элементы, кроме первых пяти
```

```{r, include=FALSE}
write.csv(x = data.frame(x = sample(-300:1000, 500)),
           file = 'indexing_vectors.csv')
```







### NA, NaN, NULL


## Матрицы

## Списки

## Датафреймы


[^1]: Такие векторы называются *свободными*.

# Типы данных

Итак, до какого-то момента мы работали только с числами, а затем начали их сравнивать, и получили что-то новое типа `TRUE` и `FALSE`. И как мы отметили, это новый _тип данных_.

А что такое вообще тип данных? **Тип данных** --- это характеристика данных, которая определяет:

* *множество допустимых значений*, которые могут принимать данные этого типа,
* и *набор операций*, которые можно осуществлять с данными этого типа.

Что это значит, будем разбираться на конкретных примерах.


## `numeric`
Этот тип данных нам уже знаком --- это числа. Например, если мы создадим переменную со значением `7` и захотим узнать её тип, то это будет выглядеть так:

```{r}
a <- 7
class(a) # эта команда выводит тип данных
```
Итак, действительно, $7$ --- это число, нас не обманули.

> Вообще-то, в R много типов числовых данных: integer (целые числа), double (числа с десятичной дробной частью), complex (комплексные числа). Последние вам вряд ли встретятся в ближайшее время, а по поводу деления первых можно особо не заморачиваться --- R сам разберется, что к чему, и переконвертирует как надо.

> Однако для интересующихся есть спойлер --- все дело в том, как [храняться числа]() на железе. А о [комплексных]() числах в R немного можно почитать [тут](http://www.r-tutor.com/r-introduction/basic-data-types/complex).

Если мы всё же хотим выяснить, что это за числовые данные, то воспользуется функцией `typeof()`:

```{r}
typeof(a)
```

На числовых данных выполняются все математические операции и различные функции, с чем мы развлекались на протяжении предыдущей главы. А множество значений этого типа, как вы понимаете, бесконечно.


## `logical`
Здесь все гораздо проще. Есть всего два значение `TRUE` и `FALSE`, то есть «истина» и «ложь». Получаются логические данные в результате сравнения --- и мы это уже тоже видели в предыдущей главе --- и на себе допускают тоже только сравнение.

```{r}
TRUE == TRUE # но вообще-то это операция, которая не несет никакого смысла
FALSE != FALSE # эта тоже не несет
FALSE == TRUE # и эта
```
`TRUE` и `FALSE` --- это логические константы, и, обратите внимание, записываются они прописными буквами. `true` и `True` не сработают. Правда есть вариант записывать их только одной буквой `T` и `F`, но c'est mauvais ton, и вот почему:

```{r}
T == TRUE
T <- FALSE
T == TRUE
```

Константы `TRUE` и `FALSE` защищены от перезаписи (на то они и константы):

<img class="taskimg" src="img/code.png">
<div class="task">
Попробуйте выполнить
```
TRUE <- FALSE
```
</div>

Поэтому мы не будем жалеть времени и символы и в угоду удобочитаемости и стабильности кода будем писать логические константы полностью.

<img class="taskimg" src="img/question.png">
<div class="task">
Хотя множество значение логического типа данных действительно состоит из двух элементов `TRUE` и `FALSE`, логических констант в R --- три штуки. Какая третья?
</div>


## `character`
Очевидно, что в практике мы не всегда имеет дело только с цифрами, мы храним ещё и текстовую информацию. Для этого есть тип данных `character` (хотя другие языки программирования с R бы [поспорили]()).

```{r}
x <- "Доброе утро, девочки!"
class(x)
```
`character` --- это строки (*string*) символов, поэтому они должны быть закавычены одинарными (`'`) или двойными (`"`) кавычками. Так R поймёт, где строка начинается и где заканчивается. Большой разницы между одинарными и двойными кавычками нет, но если у вас кавычки внутри кавычек, здесь надо быть аккуратным:

```{r}
x <- 'Мужчина громко зашёл в комнату и высказал решительное "здравствуйте"'
x
```

> А вообще, есть беспроигрышный [и типографически верный] вариант:
```{r}
x <- 'Мужчина громко зашёл в комнату и высказал решительное «здравствуйте»'
x
```

> Конечно, чтобы разговор и типах данных был полным, необходимо сказать о таком типе данных как `factor`. Однако он не является «базовым» типом, поэтому мы обсудим его устройство и работу с ним, когда непосредственно с ним столкнёмся.

## Coercion [part one]

А что будет, если мы пренебрежём допустимыми операциями и попробуем, например, сложить не-числа? Допустим, так:

```{r}
TRUE + TRUE # складываем две истины
```

Внезапно, команда выполнилась. Можно задаться вопросом, почему именно так, ведь [правила алгебры логики]() говорят, что должно быть по-другому. Опуская детали, скажем, что оператор `+` несет только арифметический, но не логический смысл, поэтому произошло следующее:

* оператор `+` умеет работать только с числовыми значениями
* но получил логические
* поэтому попробовал привести их к числовым
* у него получилось --- `TRUE` легко и непринуждено приводится к `1`, а `FALSE` к `0`[^1]
* далее выполнилось сложение

Такое поведение называется **приведение типов (coercion)**. Подробно мы его будем обсуждать позже, когда изучим структуры данных и поймем, какие опасности это может за собой влечь. Сейчас же ознакомимся с некоторыми примерами.

Приведение типов сработает не всегда. Например, если мы попытаемся сложить строки[^2], то получим ошибку:

```{r, error=TRUE}
"abc" + "cbd"
```

Чтобы контролировать приведение типов, есть семейство функций `as.*()`. Посмотрим, как они работают.

```{r}
# приводим логические данные в числовым
as.numeric(TRUE)
as.numeric(FALSE)

# приводим числовые данные к логическим
as.logical(1)
as.logical(0)
as.logical(-1) ## наблюдаем, что все не так однозначно
as.logical(0.4)
as.logical(sqrt(2))

# числовые данные к строке
as.character(23)
as.character(-150)

# логические данные к строке
as.character(TRUE)
as.character(FALSE)
```

<img class="taskimg" src="img/code.png">
<div class="task">
А какой результат выдаст следующая команда?
```
as.character(as.numeric(FALSE))
```

<div class="autocheck">
<input class="taskinput" id="input1" type="text">
<input class="taskcheck" type="button" value="Проверить" onClick="check1()">
<div class="taskans" id="taskans1" hidden></div>
</div>

</div>

```{js, echo=FALSE}
var input1 = document.getElementById("input1")
var taskans1 = document.getElementById("taskans1")

function check1() {
  if (input1.value == '"0"') {
    taskans1.hidden = false;
    taskans1.innerHTML = 'Верно!';
    taskans1.style = "color:  #00aa4a";
  } else
  {
    taskans1.hidden = false;
    taskans1.innerHTML = 'У меня другой ответ…';
    taskans1.style = "color:  #b73239";
  }
}
```


> Поздравляю! Мы закончили с основами основ! Пора переходить к самому важному и интересному --- структурам данных, а именно -- векторам!


[^1]: Почему так? [Потому что]().
[^2]: Хотя, например, для JavaScript [сложение строк](https://learn.javascript.ru/operators#slozhenie-strok-pri-pomoschi-binarnogo) --- стандартная процедура.
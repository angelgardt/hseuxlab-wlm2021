# Строки {#strings}

Мы уже знакомились со строковым типом данных `character`. Но мы обозначили, что многие операции над этим типом невозможны (например, нельзя сложить две строки). Возникает вопрос: что делать?

Для начала научимся ставить дополнительные пакеты.


## Установка дополнительных пакетов

В самом начале мы [упоминали](#whyr), что R имеет большие возможности расширения функционала с помощью специальных пакетов. Для работы со строками нам будут нужны два --- `stringi` («стринг-ай») и `stringr` («стринг-ар»). На их примере мы и разберем механизм установки и подключения дополнительных пакетов.

**Пакет** --- это набор функций, не входящих в «базовую комплектацию R», которые, как правило, специализированы под те или иные задачи. В нашем случае --- под работу со строками. Поэтому сначала пакет необходимо скачать на комп:

```{r, eval=FALSE}
install.packages(c("stringi", "stringr"))
```

В функцию `install.packages()` необходимо передать *строковый вектор*, содержащий названия пакетов, которые мы бы хотели установить.

Часто одни пакеты ссылаются на функции других, поэтому можно указать в аргументе `dependencies` `TRUE`, чтобы попутно установились *зависимые* пакеты.

```{r, eval=FALSE}
install.packages(c("stringi", "stringr"), dependencies = TRUE)
```

> По умолчанию пакеты скачиваются с репозитория **CRAN** --- основное хранилище, где лежит подавляющее большинство пакетов и всякого разного. Но может быть такое, что установить соединение с этим репозиторием по каким-либо причинам не получается. Чтобы пофиксить сей баг, нужно указать в настройках какое-либо из зеркал. `Options → Packages → Primary CRAN repository → Change…`, и выбрать что-то. Если не помогло --- попробуйте ещё.

Но мало просто скачать пакет. Надо его ещё подключить к текущей сессии, в которой мы работаем. Для этого используется функция

```{r}
library(stringi)
library(stringr)
```

Ей уже надо скормить название пакета без кавычек, и для подключения каждого пакета потребуется написать новую строчку.

> Тут запутываются термины «пакет» и «библиотека», но опустим эти детали и примем сей момент как есть…

После того, как мы подключили пакет к данной сессии, мы можем использовать функции из него.

Кайф, поехали!


## Создание строк

Можно сделать строку руками (наблюдайте за кавычками):

```{r}
s1 <- "сложившаяся структура организации влечет за собой процесс внедрения и модернизации новых предложений"
s1
```
```{r, error=TRUE}
s2 <- 'С другой стороны постоянный количественный "рост" и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации'
s2
```
```{r, error=TRUE}
s3 <- "С другой стороны постоянный количественный "рост" и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации"
s3
```
```{r}
s4 <- "С другой стороны постоянный количественный 'рост' и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации"
s4
```
```{r}
s5 <- "С другой стороны постоянный количественный «рост» и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации"
s5
```
```{r}
s6 <- "" # это пустая строка
s6
```

Также можно использовать функцию `character()`[^1] для создания вектора из пустых строк:

```{r}
character(5)
```

А также функции для приведения типов, которые мы уже обсуждали:

```{r}
as.character(1:30)
```

Кроме того, существуют встроенные текстовые векторы:

```{r}
letters
LETTERS
```

<img class="taskimg" src="img/question.png>
<div class="task">
Есть ещё встроенные векторы, которые содержат названия месяцев и аббревиатуры названий месяцев. Отыщите их.
</div>

Мы умеем генерировать числавые последовательности. Можно также генерировать и строки. Например, когда вы хотите сгенерировать ID для испытуемых не просто как числа, а как уникальные текстовые значения:

```{r}
stri_rand_strings(n = 10, length = 5)
```

> Фнукции из пакета `stringi` начинаются с префикса `stri`, а функции пакета `stringr` --- с префикса `str`. Их легко можно опознать.

<img class="taskimg" src="img/code.png">
<div class="task">
Средствами `stringi` можно генерировать не только случайные строки, но и [«рыбу»-текст](https://gusarov-group.by/wiki-internet-marketologa/ryba/). Один из вариант такого текста --- широко известный «Lorem ipsum». Найдите функцию, которая генерирует такой текст и сгенерируйте четыре абзаца.

```{r, echo=FALSE}
stri_rand_lipsum(n_paragraphs = 4)
```
</div>

## Конкатенация строк

Строки можно соединять воедино:

```{r}
paste('first', 'second', 'third') # базовый R
paste('first', 'second', 'third', sep = "_")
paste0('first', 'second', 'third')
stri_c('first', 'second', 'third') # пакет stringi
stri_c('first', 'second', 'third', sep = " & ") # пакет stringi
```

<img class="taskimg" src="img/code.png">
<div class="task">
Сгенерируйте вектор, который будет описывать различные сочетания условий вашего гипотетического эксперимента, который вы сможете добавить в гипотетический датафрейм. Пусть у вас будет десять испытуемых, для каждого из которого в датафрейме предусмотрено четыре строки: две под условие `A1` и две под условие `A2`. В свою очередь каждое из условий `A` может сочетаться с вариантами условия `B` (`B1` и `B2`). В итоге у вас должен получиться вектор, каждое значение которого структурно выглядит так: `ID_условиеA_условиеB`.

```{r, echo=FALSE}
s_exp <- stri_c(
  rep(1:10, each=4),
  rep(
    stri_c(rep("A", 2), 1:2),
    each = 2),
  rep(
    str_c(rep("B", 2), 1:2)
  ), sep = "_"
  )
s_exp
```
</div>


## Разделение строк

Если добрый коллега записал экспериментальные условия в одну переменную как выше, а вам нужно делать по ним, например, какую-нибудь анову, то можно на него долго ругаться, а можно разделить строки обратно:

```{r}
str_split(s_exp, pattern = "_")
```

Нам вернулся список. Шо с ним делать --- вопрос хороший. Можно развернуть список в вектор и индексацией вытащить нужные нам части.

<img class="taskimg" src="img/code.png">
<div class="task">
Возьмите список, которые вернула функция `str_split()`, разверните его в вектор с помощью функции `unlist()` и вытащите из него по отдельности ID, условия `A` и условия `B`.

```{r, echo=FALSE}
s_unlisted <- unlist(str_split(s_exp, pattern = "_"))
s_unlisted[seq(1, 120, 3)]
s_unlisted[seq(2, 120, 3)]
s_unlisted[seq(3, 120, 3)]
```
</div>

Но есть более удобная функция `separate()`, которая разбивает субстроки сразу по колонкам. Её мы вспомним, когда будет говорить о предобработке данных.


## Сортировка строк

Строки можно сортировать:

```{r}
unsorted_s <- paste0(
  sample(LETTERS, size = length(LETTERS), replace = TRUE),
  sample(letters, size = length(letters)),
  sample(letters, size = length(letters))
) # делаем несортированный вектор из трёхбуквенных «слов»
unsorted_s
```

Сортируем: 

```{r}
sort(unsorted_s) # можно базовой функцией
```

```{r}
str_sort(unsorted_s) # можно функцией из пакета stringr
```

Строки сортируются в [*лексикографическом порядке*](https://ru.wikipedia.org/wiki/Лексикографический_порядок). Обратите внимание, что порядок сортировки зависит от того, в какой *локали* мы работаем, то есть от того, алфавит какого языка используется для определения лексикографического порядка:

```{r}
str_sort(c("э", "а", "у", "i"), locale = 'en') # по умолчанию
str_sort(c("э", "а", "у", "i"), locale = 'ru') # русский
```

> Сортировок существует [много разных](https://www.youtube.com/watch?v=BeoCbJPuvSE). Но чем больше у вас данные, тем медленнее будет работать базовый `sort()`. Поэтому используйте `str_sort()`.


## Изменение регистра

Допусти вы собирали данные онлайн, и у вас было поле ступень образования, в которой респонденты должны быть указать бакалавриат/магистратура/аспирантура. Но по каким-то причинам, разработчик онлайн-формы не подумал, что хорошо бы сделать это поле списком, из котрого можно выбирать, и оставил его как обычное текстовое поле. Теперь у вас в данных есть «бакалавриат», «Бакалавриат» и какой-нибудь «БАкалавриат», то вообще-то одно и то же. Напасти подобного рода можно победить, если привести строки к единому регистру:

```{r}
str_to_lower(c("Бакалавриат", "БАКАЛАВРИАТ", "АСпирантура", "магистратура"))
str_to_upper(c("Бакалавриат", "БАКАЛАВРИАТ", "АСпирантура", "магистратура"))
```

> Но при таком способе сбора данных могли возникнуть и другие ошибки, так что лучше задуматься об их предотвращении заранее!


## Поиск подстроки

Если нам надо найти какую-то подстроку, то мы можем использоваться функцию `str_detect()`:

```{r}
str_detect(unsorted_s, 'b') # ищем все элементы, в которых есть маленькая «b»
unsorted_s[str_detect(unsorted_s, 'b')] # а вот и сами элементы
```

Можно подсчитать число вхождений подстроки в строке:

```{r}
str_count(unsorted_s, 'a')
```


## Изменение строк

Раз мы умеем искать подстроку, то, наверное, её можно и как-то изменять.

### Выделение подстроки

```{r}
str_sub(unsorted_s, start = 1, end = 2) # по индексам
```

### Замена подстроки

```{r}
str_replace(unsorted_s, pattern = "b", replacement = "Ц")
```

### Удаление подстроки

```{r}
str_remove(unsorted_s, 'b')
```

### Транслитерация строк

```{r}
stri_trans_general("русский текст, который должен быть написан латиницей",
                   'cyrillic-latin')
```


## Регулярные выражения

Но часто нас интересует не конкретная подстрока, и все варианты подстрок, которые имеют определенную структуру. Например, мы хотим найти корректно введенные даты рождения в нашем датасете. Пусть по условию дата должна иметь формат `DD.MM.YYYY`. И у нас есть вот такой вектор:

```{r}
dates <- c('21.92.2001', '01.04.1994', '5-3-2011', '6/04/1999')
```

Ну, так как у нас сейчас совсем игрушечные данные, мы можем смотреть на них глазами и видеть, что у нас в прицнипе три адекватные даты, но записаны по-разному, и одна верного формата, но с 92 месяцем.

Чтобы задать структуру паттерна, который мы хотим найти, используются **регулярные выражения**.

> Чтобы отображать их работу, будем пользоваться функцией `str_view_all()`.

### Метасимволы

Если мы попробуем поискать точки в наших датах, то просто так мы их не найдем:

```{r}
str_view_all(dates, pattern = ".")
```

Подсветились все символы, так как точка в регулярных выражениях --- [специальный символ](#quant). Поэтому чтобы указать, что нас интересуют собственно точки, нужно их *экранировать*.

```{r}
str_view_all(dates, pattern = '\\.')
```

Так лучше. Еще к специальным знакам (метасимфолам) относятся `$`, `*`, `+`, `?`, `^`, `[`, `]`, и другие.



### Классы знаков

В датах нас интересуют цифры, и для них есть специальное обозначение:

```{r}
str_view_all(dates, pattern = '\\d') # ищем цифры
str_view_all(dates, pattern = '\\D') # ищем не-цифры
```

Другие классы символов можно найти в следующих примерах:

```{r}
str_view_all('успешный балбес', '\\s') # пробелы
str_view_all('успешный балбес', '\\S') # не-пробелы
str_view_all('верно ведь, что здесь что-то есть', '\\w') # не пробелы и не знаки препинания
str_view_all('верно ведь, что здесь что-то есть', '\\W') # пробелы и знаки препинания
```


### Квантификация {#quant}

Можно указать, сколько раз должен встречаться тот или иной символ:

* `?` --- ноль или один раз
* `*` --- ноль или более раз
* `+` --- один или более раз
* `{n}` --- n раз

Например, найдем все группировки по два числа:

```{r}
str_view_all(dates, '\\d{2}')
```

Итак, теперь мы можем вытащить все корректные даты, которые есть в нашем векторе:

```{r}
str_view_all(dates, '\\d{2}\\.[01]\\d{1}\\.\\d{4}')
```

Она получилась всего одна. Но в целом в нашим набором условий это справедливо.


<img class="taskimg" src="img/code.png">
<div class="task">
Как мы отмечали выше, в нашем векторе в датами есть ещё две даты, который выглядят адекватно, но немного отличаются форматом, в котором они записаны. Подправьте их формат с помощью функций, изученных выше, и измените регулярное выражение так, чтобы оно обнаруживало и их тоже.

*Подсказка: возможно, вам понадобятся некоторые варианты выше упомянутых функций.*

```{r, echo=FALSE}
str_view_all(
  str_replace_all(dates, pattern = "[/-]", replacement = "."),
  '\\d{1,2}\\.[01]{0,1}\\d{1}\\.\\d{4}')
```
</div>



[^1]: Ещё есть `numeric()` и `logical()`, например.